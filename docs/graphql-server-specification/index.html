<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>GraphQL 서버 명세 · Relay</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="이 문서에선 Relay가 GraphQL 서버에 대해 가지고 있는 가정을 살펴보고, GraphQL 스키마 예제를 통해 실제 쓰임을 알아볼 수 있습니다."/><meta name="docsearch:version" content="v8.0.0-ko.0"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="GraphQL 서버 명세 · Relay"/><meta property="og:type" content="website"/><meta property="og:url" content="https://relay.dev/"/><meta property="og:description" content="이 문서에선 Relay가 GraphQL 서버에 대해 가지고 있는 가정을 살펴보고, GraphQL 스키마 예제를 통해 실제 쓰임을 알아볼 수 있습니다."/><meta property="og:image" content="https://relay.dev/img/relay.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://relay.dev/img/relay.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="/js/redirect.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><h2 class="headerTitle">Relay</h2></a><a href="/versions"><h3>v8.0.0-ko.0</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/introduction-to-relay" target="_self">문서</a></li><li class=""><a href="/help" target="_self">도움</a></li><li class=""><a href="https://github.com/facebook/relay" target="_self">GitHub</a></li><li class=""><a href="https://github.com/relay-ko/relay-ko.github.io" target="_self">🇰🇷한국어 번역</a></li><li class=""><a target="_self"></a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>가이드</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">시작하기<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/introduction-to-relay">Relay 시작하기</a></li><li class="navListItem"><a class="navItem" href="/docs/prerequisites">사전 준비사항</a></li><li class="navListItem"><a class="navItem" href="/docs/installation-and-setup">설치 및 설정</a></li><li class="navListItem"><a class="navItem" href="/docs/quick-start-guide">빠른 시작 가이드</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">API 레퍼런스<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/graphql-in-relay">Relay에서의 GraphQL</a></li><li class="navListItem"><a class="navItem" href="/docs/relay-environment">Relay Environment</a></li><li class="navListItem"><a class="navItem" href="/docs/network-layer">Network Layer</a></li><li class="navListItem"><a class="navItem" href="/docs/query-renderer">QueryRenderer</a></li><li class="navListItem"><a class="navItem" href="/docs/fragment-container">Fragment Container</a></li><li class="navListItem"><a class="navItem" href="/docs/refetch-container">Refetch Container</a></li><li class="navListItem"><a class="navItem" href="/docs/pagination-container">Pagination Container</a></li><li class="navListItem"><a class="navItem" href="/docs/mutations">Mutations</a></li><li class="navListItem"><a class="navItem" href="/docs/subscriptions">Subscriptions</a></li><li class="navListItem"><a class="navItem" href="/docs/relay-store">Relay Store</a></li><li class="navListItem"><a class="navItem" href="/docs/fetch-query">fetchQuery</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">가이드<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/routing">라우팅</a></li><li class="navListItem"><a class="navItem" href="/docs/relay-debugging">디버깅</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/graphql-server-specification">GraphQL 서버 명세</a></li><li class="navListItem"><a class="navItem" href="/docs/persisted-queries">Persisted Queries</a></li><li class="navListItem"><a class="navItem" href="/docs/type-emission">타입 생성</a></li><li class="navListItem"><a class="navItem" href="/docs/testing-relay-components">Relay 컴포넌트를 테스트하기</a></li><li class="navListItem"><a class="navItem" href="/docs/local-state-management">로컬 상태 관리</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">원칙과 설계<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/thinking-in-graphql">Thinking in GraphQL</a></li><li class="navListItem"><a class="navItem" href="/docs/thinking-in-relay">Thinking in Relay</a></li><li class="navListItem"><a class="navItem" href="/docs/architecture-overview">아키텍쳐 살펴보기</a></li><li class="navListItem"><a class="navItem" href="/docs/compiler-architecture">컴파일러 설계</a></li><li class="navListItem"><a class="navItem" href="/docs/runtime-architecture">런타임 설계</a></li><li class="navListItem"><a class="navItem" href="/docs/videos">영상</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">커뮤니티<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/community-learning-resources">커뮤니티 학습 자료</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/relay-ko/relay-ko.github.io/edit/develop/docs/GraphQL-ServerSpecification.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 class="postHeaderTitle">GraphQL 서버 명세</h1></header><article><div><span><p>이 문서에선 Relay가 GraphQL 서버에 대해 가지고 있는 가정을 살펴보고, GraphQL 스키마 예제를 통해 실제 쓰임을 알아볼 수 있습니다.</p>
<p>목차:</p>
<ul>
<li><a href="#시작하기">시작하기</a></li>
<li><a href="#스키마">스키마</a></li>
<li><a href="#오브젝트-식별">오브젝트 식별</a></li>
<li><a href="#커넥션">커넥션</a></li>
<li><a href="#뮤테이션">뮤테이션</a></li>
<li><a href="#더-읽어보기">더 읽어보기</a></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="시작하기"></a><a href="#시작하기" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>시작하기</h2>
<p>Relay는 GraphQL 서버가 아래의 세가지 기능을 제공한다고 가정합니다.</p>
<ol>
<li>객체를 다시 가져오는 (re-fetching) 하는 메커니즘.</li>
<li>커넥션을 통해 페이지를 이동하는 방법.</li>
<li>뮤테이션 작업을 추적가능하게 하는 구조.</li>
</ol>
<p>이 문서의 예제에선 위의 세가지를 모두 다룹니다. 세세하진 않지만, Relay의 핵심 가정을 빠르게 살펴보고 더 구체화된 구현을 알아보기 위한 맥락을 제공하기 위해 고안되었습니다.</p>
<p>그럼, GraphQL 쿼리를 이용해 오리지널 스타워즈 삼부작의 함선(ships)과 팩션(faction)을 쿼리하는 상황을 생각해봅시다.</p>
<p>이미 GraphQL에 대해선 친숙하다고 가정합니다. 만약 아니라면, <a href="https://github.com/graphql/graphql-js">GraphQL.js</a>의 README를 읽어보는 것이 좋습니다.</p>
<p><a href="https://en.wikipedia.org/wiki/Star_Wars">스타워즈</a>에 대해서도 잘 알고 있다는 가정을 하고 있습니다. 아직 접해보지 않으신 분들은 1977년 개봉작부터 시작하시면 됩니다. 참고로 예제는 1997년 스페셜 에디션작을 직접적으로 다루고 있습니다.</p>
<h2><a class="anchor" aria-hidden="true" id="스키마"></a><a href="#스키마" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>스키마</h2>
<p>아래의 스키마는 Relay에서 사용되는 GraphQL 서버가 구현해야하는 기능을 표현하기 위해 사용됩니다.
팩션과 함선이 핵심 타입이며, 하나의 팩션은 많은 함선을 가질 수 있습니다. 아래의 스키마는 GraphQL.js 의 <a href="https://github.com/graphql/graphql-js/blob/master/src/utilities/schemaPrinter.js"><code>schemaPrinter</code></a>의 결과물입니다.</p>
<pre><code class="hljs">interface Node {
  id: ID!
}
<span class="hljs-built_in">
type </span>Faction implements Node {
  id: ID!
  name: String
  ships: ShipConnection
}
<span class="hljs-built_in">
type </span>Ship implements Node {
  id: ID!
  name: String
}
<span class="hljs-built_in">
type </span>ShipConnection {
  edges: [ShipEdge]
  pageInfo: PageInfo!
}
<span class="hljs-built_in">
type </span>ShipEdge {
  cursor: String!
  node: Ship
}
<span class="hljs-built_in">
type </span>PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}
<span class="hljs-built_in">
type </span>Query {
  rebels: Faction
  empire: Faction
  node(id: ID!): Node
}

input IntroduceShipInput {
  factionId: String!
  shipNamed: String!
}
<span class="hljs-built_in">
type </span>IntroduceShipPayload {
  faction: Faction
  ship: Ship
}
<span class="hljs-built_in">
type </span>Mutation {
  introduceShip(input: IntroduceShipInput!): IntroduceShipPayload
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="오브젝트-식별"></a><a href="#오브젝트-식별" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>오브젝트 식별</h2>
<p><code>Faction</code>과 <code>Ship</code>은 리페치(refetch)시 사용가능한 식별자를 가지고 있습니다. 식별자는 루트 쿼리 타입의 <code>Node</code> 인터페이스와 <code>node</code> 필드를 통해 Relay에 노출됩니다.</p>
<p><code>Node</code> 인터페이스는 <code>ID!</code> 타입의 단일 필드 <code>id</code>를 가집니다. <code>node</code> 루트 필드는 <code>ID!</code>라는 단일 인자를 받고 <code>Node</code>를 반환합니다. 이 둘(<code>Node</code>와 <code>node</code>)를 통해 리페칭이 가능합니다. <code>node</code> 필드가 반환하는 <code>id</code>를 전달하면, 원하는 객체를 다시 가져올 수 있습니다.</p>
<p>반란군(rebels)의 ID를 쿼리해보며 직접 확인해봅시다.</p>
<pre><code class="hljs"><span class="hljs-attribute">query</span> RebelsQuery {
  <span class="hljs-section">rebels</span> {
    <span class="hljs-attribute">id</span>
    name
  }
}
</code></pre>
<p>위의 쿼리는 아래를 반환합니다.</p>
<pre><code class="hljs css language-json">{
  <span class="hljs-attr">"rebels"</span>: {
    <span class="hljs-attr">"id"</span>: <span class="hljs-string">"RmFjdGlvbjox"</span>,
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Alliance to Restore the Republic"</span>
  }
}
</code></pre>
<p>이제 반란군의 ID를 알았으니, 다시 그 정보를 가져오는 것이 가능합니다.</p>
<pre><code class="hljs">query RebelsRefetchQuery {
  node(<span class="hljs-built_in">id</span>: <span class="hljs-string">"RmFjdGlvbjox"</span>) {
    <span class="hljs-built_in">id</span>
    ... <span class="hljs-keyword">on</span> Faction {
      <span class="hljs-built_in">name</span>
    }
  }
}
</code></pre>
<p>RebelsRefetchQuery는 아래를 반환합니다.</p>
<pre><code class="hljs css language-json">{
  <span class="hljs-attr">"node"</span>: {
    <span class="hljs-attr">"id"</span>: <span class="hljs-string">"RmFjdGlvbjox"</span>,
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Alliance to Restore the Republic"</span>
  }
}
</code></pre>
<p>같은 걸 Empire에 대해 반복하면, 다른 ID가 반환됨을 볼 수 있습니다. 마찬가지로 반환된 ID를 이용해 다시 가져오는 리페칭 작업을 쉽게 할 수 있습니다.</p>
<pre><code class="hljs"><span class="hljs-attribute">query</span> EmpireQuery {
  <span class="hljs-section">empire</span> {
    <span class="hljs-attribute">id</span>
    name
  }
}
</code></pre>
<p>EmpireQuery는 아래를 반환합니다.</p>
<pre><code class="hljs css language-json">{
  <span class="hljs-attr">"empire"</span>: {
    <span class="hljs-attr">"id"</span>: <span class="hljs-string">"RmFjdGlvbjoy"</span>,
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Galactic Empire"</span>
  }
}
</code></pre>
<p>그리고</p>
<pre><code class="hljs">query EmpireRefetchQuery {
  node(<span class="hljs-built_in">id</span>: <span class="hljs-string">"RmFjdGlvbjoy"</span>) {
    <span class="hljs-built_in">id</span>
    ... <span class="hljs-keyword">on</span> Faction {
      <span class="hljs-built_in">name</span>
    }
  }
}
</code></pre>
<p>위의 쿼리는 아래를 반환합니다.</p>
<pre><code class="hljs css language-json">{
  <span class="hljs-attr">"node"</span>: {
    <span class="hljs-attr">"id"</span>: <span class="hljs-string">"RmFjdGlvbjoy"</span>,
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Galactic Empire"</span>
  }
}
</code></pre>
<p><code>Node</code> 인터페이스와 <code>node</code> 필드는 리페칭을 위해 전역적으로 유일한 ID가 있다고 가정합니다. 전역적으로 유일한 ID가 없는 시스템이라면 보통 타입과 타입 특정 ID를 합성해서 만들어낼 수 있습니다.</p>
<p>이 예제에서의 ID는 base64 스트링입니다. ID의 정보는 쉽게 노출되선 안되기 때문에 (<code>node</code>의 <code>id</code> 인자에 전달되어야 하는 유일한 것은 변하지 않을 객체의 ID 값) base64 처리를 통해 불투명하게 만드는 것이 GraphQL에서의 관례입니다.</p>
<p>서버측 동작에 대한 자세한 가이드는 <a href="https://graphql.org/learn/global-object-identification/">GraphQL Object Identification</a>에서 찾아보실 수 있습니다.</p>
<h2><a class="anchor" aria-hidden="true" id="커넥션"></a><a href="#커넥션" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>커넥션</h2>
<p>스타워즈 세계관에서 한 팩션은 많은 함선을 가지고 있습니다. Relay는 일대다 관계를 표준화된 방식으로 표현하는 기능을 통해 이를 쉽게 조작할 수 있도록 합니다. 이 표준 커넥션 모델은 커넥션들을 원하는 만큼 자르고(slice) 페이지네이션 하는 방법을 제공합니다.</p>
<p>rebels의 첫번째 함선을 요청해봅시다.</p>
<pre><code class="hljs">query RebelsShipsQuery {
  rebels {
    name,
    ships(first: <span class="hljs-number">1</span>) {
      edges {
        <span class="hljs-keyword">node</span> <span class="hljs-title">{
          name</span>
        }
      }
    }
  }
}
</code></pre>
<p>위 쿼리는</p>
<pre><code class="hljs css language-json">{
  <span class="hljs-attr">"rebels"</span>: {
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Alliance to Restore the Republic"</span>,
    <span class="hljs-attr">"ships"</span>: {
      <span class="hljs-attr">"edges"</span>: [
        {
          <span class="hljs-attr">"node"</span>: {
            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"X-Wing"</span>
          }
        }
      ]
    }
  }
}
</code></pre>
<p>를 반환합니다.
<code>ships</code>에 <code>first</code> 인자를 사용하여 결과값의 첫번째를 잘라오도록 했습니다. 만약 이 ships에 페이지를 메기고 싶다면 어떻게 해야 할까요? 각각의 엣지엔 페이지를 메길 수 있도록 하는 커서가 존재합니다. 이번에는 첫 두개의 함선을 질의하며 커서도 가져오도록 해봅시다.</p>
<pre><code class="hljs">query MoreRebelShipsQuery {
  rebels {
    name,
    ships(first: <span class="hljs-number">2</span>) {
      edges {
        cursor
        <span class="hljs-keyword">node</span> <span class="hljs-title">{
          name</span>
        }
      }
    }
  }
}
</code></pre>
<p>의 결과로</p>
<pre><code class="hljs css language-json">{
  <span class="hljs-attr">"rebels"</span>: {
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Alliance to Restore the Republic"</span>,
    <span class="hljs-attr">"ships"</span>: {
      <span class="hljs-attr">"edges"</span>: [
        {
          <span class="hljs-attr">"cursor"</span>: <span class="hljs-string">"YXJyYXljb25uZWN0aW9uOjA="</span>,
          <span class="hljs-attr">"node"</span>: {
            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"X-Wing"</span>
          }
        },
        {
          <span class="hljs-attr">"cursor"</span>: <span class="hljs-string">"YXJyYXljb25uZWN0aW9uOjE="</span>,
          <span class="hljs-attr">"node"</span>: {
            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Y-Wing"</span>
          }
        }
      ]
    }
  }
}
</code></pre>
<p>를 얻습니다.
커서가 base64 스트링임을 주목하세요. 이전처럼 서버는 의미를 쉽게 알아볼 수 없는 불투명한 스트링을 반환하고 있습니다. 이 스트링을 <code>ships</code> 필드의 <code>after</code> 인자로 보내서 이전 결과의 마지막 함선으로부터 다음 3개의 함선을 질의할 수 있습니다.</p>
<pre><code class="hljs">query EndOfRebelShipsQuery {
  rebels {
    <span class="hljs-built_in">name</span>,
    ships(<span class="hljs-keyword">first</span>: <span class="hljs-number">3</span> <span class="hljs-keyword">after</span>: <span class="hljs-string">"YXJyYXljb25uZWN0aW9uOjE="</span>) {
      edges {
        cursor,
        node {
          <span class="hljs-built_in">name</span>
        }
      }
    }
  }
}
</code></pre>
<p>위의 쿼리는</p>
<pre><code class="hljs css language-json">
{
  <span class="hljs-attr">"rebels"</span>: {
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Alliance to Restore the Republic"</span>,
    <span class="hljs-attr">"ships"</span>: {
      <span class="hljs-attr">"edges"</span>: [
        {
          <span class="hljs-attr">"cursor"</span>: <span class="hljs-string">"YXJyYXljb25uZWN0aW9uOjI="</span>,
          <span class="hljs-attr">"node"</span>: {
            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"A-Wing"</span>
          }
        },
        {
          <span class="hljs-attr">"cursor"</span>: <span class="hljs-string">"YXJyYXljb25uZWN0aW9uOjM="</span>,
          <span class="hljs-attr">"node"</span>: {
            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Millenium Falcon"</span>
          }
        },
        {
          <span class="hljs-attr">"cursor"</span>: <span class="hljs-string">"YXJyYXljb25uZWN0aW9uOjQ="</span>,
          <span class="hljs-attr">"node"</span>: {
            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Home One"</span>
          }
        }
      ]
    }
  }
}
</code></pre>
<p>를 반환합니다.
좋군요! 그럼 계속해서 이 이후의 4개를 가져오도록 합시다!</p>
<pre><code class="hljs">query RebelsQuery {
  rebels {
    <span class="hljs-built_in">name</span>,
    ships(<span class="hljs-keyword">first</span>: <span class="hljs-number">4</span> <span class="hljs-keyword">after</span>: <span class="hljs-string">"YXJyYXljb25uZWN0aW9uOjQ="</span>) {
      edges {
        cursor,
        node {
          <span class="hljs-built_in">name</span>
        }
      }
    }
  }
}
</code></pre>
<p>위 쿼리는</p>
<pre><code class="hljs css language-json">{
  <span class="hljs-attr">"rebels"</span>: {
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Alliance to Restore the Republic"</span>,
    <span class="hljs-attr">"ships"</span>: {
      <span class="hljs-attr">"edges"</span>: []
    }
  }
}
</code></pre>
<p>를 반환합니다.
흠. 이제 더 이상 함선이 없군요. 반란군은 함선이 다섯대 밖에 없었나봅니다. 커넥션의 끝에 다다랐다는 것을 추가적인 라운드트립 없이 알면 좋겠습니다. 커넥션 모델은 이 정보를 <code>PageInfo</code> 라는 타입에서 노출시킵니다. 함선을 반환했던 두 쿼리들에 이번에는 <code>hasNextPage</code>를 추가로 요청해봅시다.</p>
<pre><code class="hljs">query <span class="hljs-class">EndOfRebelShipsQuery </span>{
  <span class="hljs-class">rebels </span>{
    name,
<span class="hljs-symbol">    originalShips:</span> ships(first: <span class="hljs-number">2</span>) {
      <span class="hljs-class">edges </span>{
        <span class="hljs-class">node </span>{
          name
        }
      }
      <span class="hljs-class">pageInfo </span>{
        hasNextPage
      }
    }
<span class="hljs-symbol">    moreShips:</span> ships(first: <span class="hljs-number">3</span> after: <span class="hljs-string">"YXJyYXljb25uZWN0aW9uOjE="</span>) {
      <span class="hljs-class">edges </span>{
        <span class="hljs-class">node </span>{
          name
        }
      }
      <span class="hljs-class">pageInfo </span>{
        hasNextPage
      }
    }
  }
}
</code></pre>
<p>이 쿼리의 결과로 아래가 반환됩니다.</p>
<pre><code class="hljs css language-json">{
  <span class="hljs-attr">"rebels"</span>: {
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Alliance to Restore the Republic"</span>,
    <span class="hljs-attr">"originalShips"</span>: {
      <span class="hljs-attr">"edges"</span>: [
        {
          <span class="hljs-attr">"node"</span>: {
            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"X-Wing"</span>
          }
        },
        {
          <span class="hljs-attr">"node"</span>: {
            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Y-Wing"</span>
          }
        }
      ],
      <span class="hljs-attr">"pageInfo"</span>: {
        <span class="hljs-attr">"hasNextPage"</span>: <span class="hljs-literal">true</span>
      }
    },
    <span class="hljs-attr">"moreShips"</span>: {
      <span class="hljs-attr">"edges"</span>: [
        {
          <span class="hljs-attr">"node"</span>: {
            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"A-Wing"</span>
          }
        },
        {
          <span class="hljs-attr">"node"</span>: {
            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Millenium Falcon"</span>
          }
        },
        {
          <span class="hljs-attr">"node"</span>: {
            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Home One"</span>
          }
        }
      ],
      <span class="hljs-attr">"pageInfo"</span>: {
        <span class="hljs-attr">"hasNextPage"</span>: <span class="hljs-literal">false</span>
      }
    }
  }
}
</code></pre>
<p>첫번째 함선에 대한 쿼리에서 GraphQL은 다음 페이지가 있다고 알려줬지만, 그 다음 쿼리에선 커넥션의 끝에 도달했다고 알려줬습니다.</p>
<p>Relay는 위에서 설명한 모든 기능들로 커넥션에 대한 추상화를 할 수 있도록 합니다. 이렇게 함으로써 직접 클라이언트 측에서 커서를 관리할 필요없이 효율적인 처리가 가능해집니다.</p>
<p>서버 동작에 대한 더 자세한 내용은 <a href="/graphql/connections.htm">GraphQL Cursor Connections</a>에 나와있습니다.</p>
<h2><a class="anchor" aria-hidden="true" id="뮤테이션"></a><a href="#뮤테이션" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>뮤테이션</h2>
<p>Relay의 뮤테이션도 공통된 패턴을 사용합니다. 뮤테이션의 루트 필드에는 <code>input</code> 이라는 단일 인자가 있고, <code>input</code>과 <code>output</code>에는 각각 클라이언트 뮤테이션 식별자가 있어 하나의 요청과 이에 대한 응답을 엮어 관리합니다.</p>
<p>뮤테이션은 동사로 이름짓는것이 관례이고, 인풋은 접미어로 &quot;Input&quot;이 붙습니다. 뮤테이션이 반환하는 객체에는 &quot;Payload&quot; 가 뒤에 붙습니다.</p>
<p>이번에 살펴볼 <code>introduceShip</code> 뮤테이션에선 2개의 타입, <code>IntroduceShipInput</code>과 <code>IntroduceShipPayload</code>가 사용됩니다.</p>
<pre><code class="hljs">input IntroduceShipInput {
  factionId: ID!
  shipName: String!
}
<span class="hljs-built_in">
type </span>IntroduceShipPayload {
  faction: Faction
  ship: Ship
}
</code></pre>
<p>입력과 페이로드를 가지고 아래의 뮤테이션을 실행할 수 있습니다.</p>
<pre><code class="hljs">mutation <span class="hljs-constructor">AddBWingQuery($<span class="hljs-params">input</span>: IntroduceShipInput!)</span> {
  introduce<span class="hljs-constructor">Ship(<span class="hljs-params">input</span>: $<span class="hljs-params">input</span>)</span> {
    ship {
      id
      name
    }
    faction {
      name
    }
  }
}
</code></pre>
<p>IntroduceShipInput은 실제로 아래의 값들을 가집니다.</p>
<pre><code class="hljs css language-json">{
  <span class="hljs-attr">"input"</span>: {
    <span class="hljs-attr">"shipName"</span>: <span class="hljs-string">"B-Wing"</span>,
    <span class="hljs-attr">"factionId"</span>: <span class="hljs-string">"1"</span>
  }
}
</code></pre>
<p>그리고 아래의 결과가 반환됩니다.</p>
<pre><code class="hljs css language-json">{
  <span class="hljs-attr">"introduceShip"</span>: {
    <span class="hljs-attr">"ship"</span>: {
      <span class="hljs-attr">"id"</span>: <span class="hljs-string">"U2hpcDo5"</span>,
      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"B-Wing"</span>
    },
    <span class="hljs-attr">"faction"</span>: {
      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Alliance to Restore the Republic"</span>
    }
  }
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="더-읽어보기"></a><a href="#더-읽어보기" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>더 읽어보기</h2>
<p>이것으로 GraphQL 서버 명세를 알아보았습니다. Relay 스펙을 준수하는 GraphQL 서버의 요구사항에 대해 더 자세히 알아보고 싶다면 <a href="/graphql/connections.htm">Relay cursor connection</a>과 <a href="https://graphql.org/learn/global-object-identification/">GraphQL global object identification</a> 를 참고하면 됩니다.</p>
<p><a href="https://github.com/graphql/graphql-relay-js">GraphQL.js Relay library</a>에서 명세를 구현한 코드(노드, 커넥션, 뮤테이션을 생성하는 헬퍼 함수)를 볼 수 있습니다. <a href="https://github.com/graphql/graphql-relay-js/tree/master/src/__tests__"><code>__tests__</code></a> 폴더에는 위의 예제들의 구현에 대한 통합 테스트가 있습니다.</p>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 2020. 2. 3. by Tony</em></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/relay-debugging"><span class="arrow-prev">← </span><span>Debugging</span></a><a class="docs-next button" href="/docs/persisted-queries"><span>Persisted Queries</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#시작하기">시작하기</a></li><li><a href="#스키마">스키마</a></li><li><a href="#오브젝트-식별">오브젝트 식별</a></li><li><a href="#커넥션">커넥션</a></li><li><a href="#뮤테이션">뮤테이션</a></li><li><a href="#더-읽어보기">더 읽어보기</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/relay.svg" alt="Relay" width="66" height="58"/></a><div><h5>문서</h5><a href="/docs/introduction-to-relay.html">시작하기</a></div><div><h5>커뮤니티</h5><a href="/users.html">유저 Showcase</a></div><div><h5>더 보기</h5><a href="https://github.com/facebook/relay">GitHub</a><a class="github-button" href="https://github.com/facebook/relay" data-icon="octicon-star" data-count-href="/facebook/relay/stargazers" data-count-api="/repos/facebook/relay#stargazers_count" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2022 Facebook Inc. / Translated by Tony (@tonyfromundefined)</section></footer></div></body></html>