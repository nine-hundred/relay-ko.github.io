<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Thinking in Relay · Relay</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Relay의 Data-fetching에 대한 접근 방식은 React에서 얻은 저희의 경험으로부터 많은 영감을 받았습니다. 일반적으로 React는 복잡한 인터페이스를 재사용가능한 컴포넌트로 쪼갭니다. 이를 통해 개발자들은 어플리케이션을 분리할 구체적인 단위에 대해 생각할 수 있게 되고, 어플리케이션 내 다른 역할을 하는 부분들 사이의 연관관계를 줄일 수 있습니다. 그리고 무엇보다 중요한 부분은 바로 **선언적**이라는 것입니다: 선언적으로 UI를 그리는 방법은 개발자로 하여금 *어떻게* UI를 그릴지에 대한 염려없이, 주어진 State로 *무엇을* 그릴지만 고민하게 만들어줍니다. 절차적 프로그래밍으로 네이티브 뷰(예: DOM)를 조작하는 이전의 접근과 다르게, React는 UI 명세를 가지고 자동으로 꼭 필요한 행동만 하게됩니다."/><meta name="docsearch:version" content="v8.0.0-ko.0"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Thinking in Relay · Relay"/><meta property="og:type" content="website"/><meta property="og:url" content="https://relay.dev/"/><meta property="og:description" content="Relay의 Data-fetching에 대한 접근 방식은 React에서 얻은 저희의 경험으로부터 많은 영감을 받았습니다. 일반적으로 React는 복잡한 인터페이스를 재사용가능한 컴포넌트로 쪼갭니다. 이를 통해 개발자들은 어플리케이션을 분리할 구체적인 단위에 대해 생각할 수 있게 되고, 어플리케이션 내 다른 역할을 하는 부분들 사이의 연관관계를 줄일 수 있습니다. 그리고 무엇보다 중요한 부분은 바로 **선언적**이라는 것입니다: 선언적으로 UI를 그리는 방법은 개발자로 하여금 *어떻게* UI를 그릴지에 대한 염려없이, 주어진 State로 *무엇을* 그릴지만 고민하게 만들어줍니다. 절차적 프로그래밍으로 네이티브 뷰(예: DOM)를 조작하는 이전의 접근과 다르게, React는 UI 명세를 가지고 자동으로 꼭 필요한 행동만 하게됩니다."/><meta property="og:image" content="https://relay.dev/img/relay.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://relay.dev/img/relay.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="/js/redirect.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><h2 class="headerTitle">Relay</h2></a><a href="/versions"><h3>v8.0.0-ko.0</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/introduction-to-relay" target="_self">문서</a></li><li class=""><a href="/help" target="_self">도움</a></li><li class=""><a href="https://github.com/facebook/relay" target="_self">GitHub</a></li><li class=""><a href="https://github.com/relay-ko/relay-ko.github.io" target="_self">🇰🇷한국어 번역</a></li><li class=""><a target="_self"></a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>원칙과 설계</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">시작하기<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/introduction-to-relay">Relay 시작하기</a></li><li class="navListItem"><a class="navItem" href="/docs/prerequisites">사전 준비사항</a></li><li class="navListItem"><a class="navItem" href="/docs/installation-and-setup">설치 및 설정</a></li><li class="navListItem"><a class="navItem" href="/docs/quick-start-guide">빠른 시작 가이드</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">API 레퍼런스<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/graphql-in-relay">Relay에서의 GraphQL</a></li><li class="navListItem"><a class="navItem" href="/docs/relay-environment">Relay Environment</a></li><li class="navListItem"><a class="navItem" href="/docs/network-layer">Network Layer</a></li><li class="navListItem"><a class="navItem" href="/docs/query-renderer">QueryRenderer</a></li><li class="navListItem"><a class="navItem" href="/docs/fragment-container">Fragment Container</a></li><li class="navListItem"><a class="navItem" href="/docs/refetch-container">Refetch Container</a></li><li class="navListItem"><a class="navItem" href="/docs/pagination-container">Pagination Container</a></li><li class="navListItem"><a class="navItem" href="/docs/mutations">Mutations</a></li><li class="navListItem"><a class="navItem" href="/docs/subscriptions">Subscriptions</a></li><li class="navListItem"><a class="navItem" href="/docs/relay-store">Relay Store</a></li><li class="navListItem"><a class="navItem" href="/docs/fetch-query">fetchQuery</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">가이드<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/routing">라우팅</a></li><li class="navListItem"><a class="navItem" href="/docs/relay-debugging">디버깅</a></li><li class="navListItem"><a class="navItem" href="/docs/graphql-server-specification">GraphQL 서버 명세</a></li><li class="navListItem"><a class="navItem" href="/docs/persisted-queries">Persisted Queries</a></li><li class="navListItem"><a class="navItem" href="/docs/type-emission">타입 생성</a></li><li class="navListItem"><a class="navItem" href="/docs/testing-relay-components">Relay 컴포넌트를 테스트하기</a></li><li class="navListItem"><a class="navItem" href="/docs/local-state-management">로컬 상태 관리</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">원칙과 설계<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/thinking-in-graphql">Thinking in GraphQL</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/thinking-in-relay">Thinking in Relay</a></li><li class="navListItem"><a class="navItem" href="/docs/architecture-overview">아키텍쳐 살펴보기</a></li><li class="navListItem"><a class="navItem" href="/docs/compiler-architecture">컴파일러 설계</a></li><li class="navListItem"><a class="navItem" href="/docs/runtime-architecture">런타임 설계</a></li><li class="navListItem"><a class="navItem" href="/docs/videos">영상</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">커뮤니티<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/community-learning-resources">커뮤니티 학습 자료</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/relay-ko/relay-ko.github.io/edit/develop/docs/PrinciplesAndArchitecture-ThinkingInRelay.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 class="postHeaderTitle">Thinking in Relay</h1></header><article><div><span><p>Relay의 Data-fetching에 대한 접근 방식은 React에서 얻은 저희의 경험으로부터 많은 영감을 받았습니다. 일반적으로 React는 복잡한 인터페이스를 재사용가능한 컴포넌트로 쪼갭니다. 이를 통해 개발자들은 어플리케이션을 분리할 구체적인 단위에 대해 생각할 수 있게 되고, 어플리케이션 내 다른 역할을 하는 부분들 사이의 연관관계를 줄일 수 있습니다. 그리고 무엇보다 중요한 부분은 바로 <strong>선언적</strong>이라는 것입니다: 선언적으로 UI를 그리는 방법은 개발자로 하여금 <em>어떻게</em> UI를 그릴지에 대한 염려없이, 주어진 State로 <em>무엇을</em> 그릴지만 고민하게 만들어줍니다. 절차적 프로그래밍으로 네이티브 뷰(예: DOM)를 조작하는 이전의 접근과 다르게, React는 UI 명세를 가지고 자동으로 꼭 필요한 행동만 하게됩니다.</p>
<p>자 이제, 어떻게 이 아이디어를 Relay에 어떻게 적용했는지 몇가지 Product Use-case들을 통해 살펴봅시다. (React에 이미 익숙하시다고 가정한 뒤 설명하겠습니다.)</p>
<h2><a class="anchor" aria-hidden="true" id="뷰를-위한-데이터를-가져오는-것"></a><a href="#뷰를-위한-데이터를-가져오는-것" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>뷰를 위한 데이터를 가져오는 것</h2>
<p>우리의 경험에 따르면, 대부분의 어플리케이션이 원하는 구동 방식은 로딩 인디케이터가 보여질때 View Hierarchy내에서 필요한 데이터를 한번에 모두 Fetch하고 데이터가 준비되면 <em>전체 뷰</em>를 한번에 그리는 것입니다.</p>
<p>이를 위한 첫번째 솔루션은 루트 컴포넌트에서 자식에게 필요한 모든 데이터를 가져오는 것입니다. 하지만 이것은 Coupling을 발생시킵니다: 하위 컴포넌트에서 변경이 발생할때마다 루트 컴포넌트가 변경 될 필요가 생깁니다. 이러한 Coupling은 버그를 만날 확률을 높이고 개발 속도를 느리게 만듭니다. 궁극적으로는, 이러한 접근방식은 React의 컴포넌트 모델의 장점을 얻을수 없게 만듭니다. 필요한 데이터를 정의하는 가장 자연스러운 부분은 루트가 아닌 각 컴포넌트 내부일것입니다.</p>
<p>두번째로 시도할 수 있는 접근방법은 <code>render()</code>를 첫 데이터 요청으로 사용하는 것입니다. 일단 간단하게 어플리케이션을 그린 뒤에, 어떤 데이터가 필요한지 파악하고, 데이터를 요청한 뒤, 다시 그릴 수 있습니다. 이것은 처음에는 좋게 보이나, 문제는 <em>컴포넌트가 어떤걸 그려야할지가 데이터를 통해서만 알 수 있다는 것입니다!</em> 다른 말로 이야기하자면, 이것은 데이터 요청을 여러번에 나눠서 실행하게 됩니다: 첫번째로 그려질때는 루트를 보고 데이터를 가져오고, 그리고 그 이후에 자식은 뭐가 필요한지를 파악한 후에 데이터를 가져오게 됩니다. 이렇게 컴포넌트 트리의 맨 아래까지 내려가게 됩니다. 만약 각 단계마다 네트워크 요청이 일어나게 된다면, 렌더링이 느려지고, 연속적인 데이터 왕복이 필요하게 됩니다. 그래서 이 문제를 해결하기 위해 우리는 전체적인 데이터 요구를 한번에, 정적으로 파악할 수 있는 방법이 필요합니다.</p>
<p>This is where GraphQL comes into play. Components specify one or multiple GraphQL fragments for some of their props describing their data requirements.</p>
<p>Each GraphQL fragment has a unique name within an application which allows us to determine the query needed to fetch the full query tree in a build step and load all the required data in a single network request efficiently at runtime.</p>
<h2><a class="anchor" aria-hidden="true" id="data-components-aka-containers"></a><a href="#data-components-aka-containers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Data Components aka Containers</h2>
<p>Relay allows developers to annotate their React components with data dependencies by creating <strong>containers</strong>. These are regular React components that wrap the originals. A key design constraint is that React components are meant to be reusable, so Relay containers must be too. For example, a <code>&lt;Story /&gt;</code> component might implement a view for rendering any <code>Story</code> item. The actual story to render would be determined by the data passed to the component: <code>&lt;Story story={ ... } /&gt;</code>. The equivalent in GraphQL are <strong>fragments</strong>: named query snippets that specify what data to fetch <em>for an object of a given type</em>. We might describe the data needed by <code>&lt;Story&gt;</code> as follows:</p>
<pre><code class="hljs">fragment Story_story <span class="hljs-keyword">on</span> Story {
  <span class="hljs-built_in">text</span>
  author {
    <span class="hljs-built_in">name</span>
    photo
  }
}
</code></pre>
<p>And this fragment can then be used to define the Story container:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> {createFragmentContainer, graphql} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay'</span>);

<span class="hljs-comment">// Plain React component.</span>
<span class="hljs-comment">// Usage: `&lt;Story story={ ... } /&gt;`</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Story</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{ ... }

<span class="hljs-comment">// Higher-order component that wraps `&lt;Story /&gt;`</span>
<span class="hljs-keyword">const</span> StoryContainer = createFragmentContainer(Story, {
  <span class="hljs-comment">// Define a fragment with a name matching the `story` prop expected above</span>
  <span class="hljs-attr">story</span>: graphql<span class="hljs-string">`
    fragment Story_story on Story {
      text
      author {
        name
        photo
      }
    }
  `</span>
})
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="rendering"></a><a href="#rendering" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Rendering</h2>
<p>In React, rendering a view requires two inputs: the <em>component</em> to render, and a <em>root</em> DOM (UI) node to render into. Rendering Relay containers is similar: we need a <em>container</em> to render, and a <em>root</em> in the graph from which to start our query. We also must ensure that the queries for the container are executed and may want to show a loading indicator while data is being fetched. Similar to <code>ReactDOM.render(component, domNode)</code>, Relay provides <code>&lt;QueryRenderer query={...} variables={...} render={...}&gt;</code> for this purpose. The <code>query</code> and <code>variables</code> define what data to fetch and <code>render</code> defines what to render. Here's how we might render <code>&lt;StoryContainer&gt;</code>:</p>
<pre><code class="hljs css language-javascript">ReactDOM.render(
  &lt;QueryRenderer
    query={graphql`
      query StoryQuery($storyID: ID!) {
        node(id: $storyID) {
          ...Story_story
        }
      }
    `}
    variables={{
      storyID: '123',
    }}
    render={(props, error) =&gt; {
      if (error) {
        return &lt;ErrorView /&gt;;
      } else if (props) {
        return &lt;StoryContainer story={props.story} /&gt;;
      } else {
        return &lt;LoadingIndicator /&gt;;
      }
    }}
  /&gt;,
  rootElement
)
</code></pre>
<p><code>QueryRenderer</code> will then fetch the data and render <code>StoryContainer</code> once the data is available. Just as React allows developers to render views without directly manipulating the underlying view, Relay removes the need to directly communicate with the network.</p>
<h2><a class="anchor" aria-hidden="true" id="data-masking"></a><a href="#data-masking" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Data Masking</h2>
<p>With typical approaches to data-fetching we found that it was common for two components to have <em>implicit dependencies</em>. For example <code>&lt;StoryHeader /&gt;</code> might use some data without directly ensuring that the data was fetched. This data would often be fetched by some other part of the system, such as <code>&lt;Story /&gt;</code>. Then when we changed <code>&lt;Story /&gt;</code> and removed that data-fetching logic, <code>&lt;StoryHeader /&gt;</code> would suddenly and inexplicably break. These types of bugs are not always immediately apparent, especially in larger applications developed by larger teams. Manual and automated testing can only help so much: this is exactly the type of systematic problem that is better solved by a framework.</p>
<p>We've seen that Relay containers ensure that GraphQL fragments are fetched <em>before</em> the component is rendered. But containers also provide another benefit that isn't immediately obvious: <strong>data masking</strong>. Relay only allows components to access data they specifically ask for in GraphQL fragments — nothing more. So if one component queries for a Story's <code>text</code>, and another for its <code>author</code>, each can see <em>only</em> the field that they asked for. In fact, components can't even see the data requested by their <em>children</em>: that would also break encapsulation.</p>
<p>Relay also goes further: it uses opaque identifiers on <code>props</code> to validate that we've explicitly fetched the data for a component before rendering it. If <code>&lt;Story /&gt;</code> renders <code>&lt;StoryHeader /&gt;</code> but forgets to include its fragment, Relay will warn that the data for <code>&lt;StoryHeader /&gt;</code> is missing. In fact, Relay will warn <em>even if</em> some other component happened to fetch the same data required by <code>&lt;StoryHeader /&gt;</code>. This warning tells us that although things <em>might</em> work now they're highly likely to break later.</p>
<h1><a class="anchor" aria-hidden="true" id="conclusion"></a><a href="#conclusion" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h1>
<p>GraphQL provides a powerful tool for building efficient, decoupled client applications. Relay builds on this functionality to provide a framework for <strong>declarative data-fetching</strong>. By separating <em>what</em> data to fetch from <em>how</em> it is fetched, Relay helps developers build applications that are robust, transparent, and performant by default. It's a great complement to the component-centric way of thinking championed by React. While each of these technologies — React, Relay, and GraphQL — are powerful on their own, the combination is a <strong>UI platform</strong> that allows us to <em>move fast</em> and <em>ship high-quality apps at scale</em>.</p>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 2020. 2. 3. by Tony</em></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/thinking-in-graphql"><span class="arrow-prev">← </span><span class="function-name-prevnext">Thinking in GraphQL</span></a><a class="docs-next button" href="/docs/architecture-overview"><span>Architecture Overview</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#뷰를-위한-데이터를-가져오는-것">뷰를 위한 데이터를 가져오는 것</a></li><li><a href="#data-components-aka-containers">Data Components aka Containers</a></li><li><a href="#rendering">Rendering</a></li><li><a href="#data-masking">Data Masking</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/relay.svg" alt="Relay" width="66" height="58"/></a><div><h5>문서</h5><a href="/docs/introduction-to-relay.html">시작하기</a></div><div><h5>커뮤니티</h5><a href="/users.html">유저 Showcase</a></div><div><h5>더 보기</h5><a href="https://github.com/facebook/relay">GitHub</a><a class="github-button" href="https://github.com/facebook/relay" data-icon="octicon-star" data-count-href="/facebook/relay/stargazers" data-count-api="/repos/facebook/relay#stargazers_count" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2022 Facebook Inc. / Translated by Tony (@tonyfromundefined)</section></footer></div></body></html>