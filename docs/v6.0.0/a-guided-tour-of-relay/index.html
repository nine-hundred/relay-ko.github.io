<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>A Guided Tour ¬∑ Relay</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="[Relay](https://relay.dev/) is a framework for managing and declaratively fetching GraphQL data. Specifically, it provides a set of APIs to fetch and declare data dependencies for React components, in colocation with component definitions themselves."/><meta name="docsearch:version" content="v6.0.0"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="A Guided Tour ¬∑ Relay"/><meta property="og:type" content="website"/><meta property="og:url" content="https://relay.dev/"/><meta property="og:description" content="[Relay](https://relay.dev/) is a framework for managing and declaratively fetching GraphQL data. Specifically, it provides a set of APIs to fetch and declare data dependencies for React components, in colocation with component definitions themselves."/><meta property="og:image" content="https://relay.dev/img/relay.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://relay.dev/img/relay.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="/js/redirect.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><h2 class="headerTitle">Relay</h2></a><a href="/versions"><h3>v6.0.0</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/v6.0.0/introduction-to-relay" target="_self">Î¨∏ÏÑú</a></li><li class=""><a href="/help" target="_self">ÎèÑÏõÄ</a></li><li class=""><a href="https://github.com/facebook/relay" target="_self">GitHub</a></li><li class=""><a href="https://github.com/relay-ko/relay-ko.github.io" target="_self">üá∞üá∑ÌïúÍµ≠Ïñ¥ Î≤àÏó≠</a></li><li class=""><a target="_self"></a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/relay-ko/relay-ko.github.io/edit/develop/docs/RelayHooks-AGuidedTourOfRelay.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 class="postHeaderTitle">A Guided Tour</h1></header><article><div><span><p><a href="https://relay.dev/">Relay</a> is a framework for managing and declaratively fetching GraphQL data. Specifically, it provides a set of APIs to fetch and declare data dependencies for React components, in colocation with component definitions themselves.</p>
<p>In this guide, we're going to go over how to use Relay to build out some of the more common use cases in apps. If you're interested in a detailed reference of our APIs, check out our <a href="api-reference.html">API Reference</a> page. Before getting started, bear in mind that we assume some level of familiarity with JavaScript, <a href="https://reactjs.org/docs/getting-started.html">React</a>, <a href="https://graphql.org/learn/">GraphQL</a>, and assume that you have set up a GraphQL Server that adheres to the <a href="graphql-server-specification.html">Relay specification</a></p>
<h2><a class="anchor" aria-hidden="true" id="example-app"></a><a href="#example-app" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Example App</h2>
<p>To see a full example using Relay Hooks and our integration with <a href="https://reactjs.org/docs/concurrent-mode-suspense.html">Suspense for Data Fetching</a>, check out: <a href="https://github.com/relayjs/relay-examples/tree/master/issue-tracker">relay-examples/issue-tracker</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="setup-and-workflow"></a><a href="#setup-and-workflow" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Setup and Workflow</h2>
<p>In case you've never worked with Relay before, here's a rundown of what you need to set up to get up and running developing with Relay:</p>
<h3><a class="anchor" aria-hidden="true" id="installation"></a><a href="#installation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Installation</h3>
<p>Install the experimental versions of React and Relay using <code>yarn</code> or <code>npm</code>:</p>
<pre><code class="hljs css language-sh">yarn add react@experimental react-dom@experimental react-relay@experimental
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="babel-plugin"></a><a href="#babel-plugin" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Babel plugin</h3>
<p>Relay requires a Babel plugin to process <code>graphql</code> tags inside your JavaScript code:</p>
<pre><code class="hljs css language-sh">yarn add --dev babel-plugin-relay graphql
</code></pre>
<p>Add <code>&quot;relay&quot;</code> to the list of plugins in your <code>.babelrc</code> file:</p>
<pre><code class="hljs css language-javascript">{
  <span class="hljs-string">"plugins"</span>: [
    <span class="hljs-string">"relay"</span>
  ]
}
</code></pre>
<p>Please note that the <code>&quot;relay&quot;</code> plugin should run before other plugins or
presets to ensure the <code>graphql</code> template literals are correctly transformed. See
Babel's <a href="https://babeljs.io/docs/plugins/#pluginpreset-ordering">documentation on this topic</a>.</p>
<p>Alternatively, instead of using <code>babel-plugin-relay</code>, you can use Relay with <a href="https://github.com/kentcdodds/babel-plugin-macros">babel-plugin-macros</a>. After installing <code>babel-plugin-macros</code> and adding it to your Babel config:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> graphql = <span class="hljs-built_in">require</span>(<span class="hljs-string">'babel-plugin-relay/macro'</span>);
</code></pre>
<p>If you need to configure <code>babel-plugin-relay</code> further, you can do so by <a href="https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/user.md#config-experimental">specifying the options in a number of ways</a>.</p>
<h3><a class="anchor" aria-hidden="true" id="relay-compiler"></a><a href="#relay-compiler" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Relay Compiler</h3>
<p>Whenever you're developing Relay components, for example by writing <a href="#fragments">Fragments</a> or <a href="#queries">Queries</a>, you will need to run the <a href="./graphql-in-relay.html#relay-compiler">Relay Compiler</a>. The Relay Compiler will read and analyze any <code>graphql</code> inside your JavaScript code, and produce a set of artifacts that will be used by Relay at runtime (i.e. when the application is running on the browser).</p>
<p>To install the compiler, you can use <code>yarn</code> or <code>npm</code>:</p>
<pre><code class="hljs css language-sh">yarn add --dev relay-compiler
</code></pre>
<p>This installs the bin script <code>relay-compiler</code> in your <code>node_modules</code> folder. It's recommended to run this from a <code>yarn</code>/<code>npm</code> script by adding a script to your <code>package.json</code> file:</p>
<pre><code class="hljs css language-js"><span class="hljs-string">"scripts"</span>: {
  <span class="hljs-string">"relay"</span>: <span class="hljs-string">"relay-compiler --src ./src --schema ./schema.graphql"</span>
}
</code></pre>
<p>or if you are using jsx:</p>
<pre><code class="hljs css language-js"><span class="hljs-string">"scripts"</span>: {
  <span class="hljs-string">"relay"</span>: <span class="hljs-string">"relay-compiler --src ./src --schema ./schema.graphql --extensions js jsx"</span>
}
</code></pre>
<p>Then, whenever you've made edits to your application files, you can run the <code>relay</code> script to run the compiler and generate new compiled artifacts:</p>
<pre><code class="hljs css language-sh"><span class="hljs-comment"># Single run</span>
yarn run relay
</code></pre>
<p>You can also pass the <code>--watch</code> option to watch for changes in your application files and automatically re-compile the artifacts (<strong>Note:</strong> Requires <a href="https://facebook.github.io/watchman">watchman</a> to be installed):</p>
<pre><code class="hljs css language-sh"><span class="hljs-comment"># Watch for changes</span>
yarn run relay --watch
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="config-file"></a><a href="#config-file" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Config file</h3>
<p>The configuration of <code>babel-plugin-relay</code> and <code>relay-compiler</code> can be applied using a single configuration file by
using the <code>relay-config</code> package. Besides unifying all Relay configuration in a single place, other tooling can leverage this to provide zero-config setup (e.g. <a href="https://github.com/relay-tools/vscode-apollo-relay">vscode-apollo-relay</a>).</p>
<p>Install the package:</p>
<pre><code class="hljs css language-sh">yarn add --dev relay-config
</code></pre>
<p>And create the configuration file:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">// relay.config.js</span>
<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-comment">// Configuration options accepted by the `relay-compiler` command-line tool and `babel-plugin-relay`.</span>
  <span class="hljs-attr">src</span>: <span class="hljs-string">"./src"</span>,
  <span class="hljs-attr">schema</span>: <span class="hljs-string">"./data/schema.graphql"</span>,
  <span class="hljs-attr">exclude</span>: [<span class="hljs-string">"**/node_modules/**"</span>, <span class="hljs-string">"**/__mocks__/**"</span>, <span class="hljs-string">"**/__generated__/**"</span>],
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="rendering-data-basics"></a><a href="#rendering-data-basics" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Rendering Data Basics</h2>
<h3><a class="anchor" aria-hidden="true" id="fragments"></a><a href="#fragments" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fragments</h3>
<p>The main building block for declaring data dependencies for React Components in Relay are <a href="https://graphql.org/learn/queries/#fragments">GraphQL fragments</a>, which are essentially a selection of fields on a GraphQL Type:</p>
<pre><code class="hljs css language-graphql">fragment UserFragment on<span class="hljs-built_in"> User </span>{
  name
  age
  profile_picture(scale: 2) {
    uri
  }
}
</code></pre>
<p>In order to declare a fragment inside your JavaScript code, you must use the <code>graphql</code> tag:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> {graphql} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

<span class="hljs-keyword">const</span> userFragment = graphql<span class="hljs-string">`
  fragment UserFragment on User {
    name
    age
    profile_picture(scale: 2) {
      uri
    }
  }
`</span>;
</code></pre>
<p>In order to <em>render</em> the data for a fragment, you can use the <strong><code>useFragment</code></strong> Hook:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {UserComponent_user$key} <span class="hljs-keyword">from</span> <span class="hljs-string">'UserComponent_user.graphql'</span>;

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);

<span class="hljs-keyword">const</span> {graphql, useFragment} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

type Props = {|
  user: UserComponent_user$key,
|};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserComponent</span>(<span class="hljs-params">props: Props</span>) </span>{
  <span class="hljs-keyword">const</span> data = useFragment(
    graphql<span class="hljs-string">`
      fragment UserComponent_user on User {
        name
        profile_picture(scale: 2) {
          uri
        }
      }
    `</span>,
    props.user,
  );

  <span class="hljs-keyword">return</span> (
    &lt;&gt;
      &lt;h1&gt;{data.name}&lt;/h1&gt;
      &lt;div&gt;
        &lt;img src={data.profile_picture?.uri} /&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}

module.exports = UserComponent;
</code></pre>
<p>Let's distill what's going on here:</p>
<ul>
<li><code>useFragment</code> takes a fragment definition and a <strong><em>fragment reference</em></strong>, and returns the corresponding <code>data</code> for that fragment and reference.</li>
<li>A <strong><em>fragment reference</em></strong> is an object that Relay uses to <strong><em>read</em></strong> the data declared in the fragment definition; as you can see, the <code>UserComponent_user</code> fragment itself just declares fields on the <code>User</code> type, but we need to know <strong><em>which</em></strong> specific user to read those fields from; this is what the fragment reference corresponds to. In other words, a fragment reference is like <strong><em>a pointer to a specific instance of a type</em></strong> that we want to read data from.</li>
<li>Note that <strong><em>the component is automatically subscribed to updates to the fragment data:</em></strong> if the data for this particular <code>User</code> is updated anywhere in the app (e.g. via fetching new data, or mutating existing data), the component will automatically re-render with the latest updated data.</li>
<li>Relay will automatically generate Flow types for any declared fragments when the compiler is run, so you can use these types to declare the type for your Component's <code>props</code>.
<ul>
<li>The generated Flow types include a type for the fragment reference, which is the type with the <strong><code>$key</code></strong> suffix: <code>&lt;fragment_name&gt;$key</code>, and a type for the shape of the data, which is the type with the <strong><code>$data</code></strong> suffix:  <code>&lt;fragment_name&gt;$data</code>; these types are available to import from files that are generated with the following name: <code>&lt;fragment_name&gt;.graphql.js</code>.</li>
<li>We use our <a href="https://github.com/relayjs/eslint-plugin-relay">lint rule</a> to enforce that the type of the fragment reference prop is correctly declared when using <code>useFragment</code>. By using a properly typed fragment reference as input, the type of the returned <code>data</code> will automatically be Flow typed without requiring an explicit annotation.</li>
<li>In our example, we're typing the <code>user</code> prop as the fragment reference we need for <code>useFragment</code>, which corresponds to the <code>UserComponent_user$key</code> imported from  <code>UserComponent_user.graphql</code>, which means that the type of <code>data</code> above would be: <code>{| name: ?string, profile_picture: ?{| uri: ?string |} |}</code>.</li>
</ul></li>
<li>Fragment names need to be globally unique. In order to easily achieve this, we name fragments using the following convention based on the module name followed by an identifier: <code>&lt;module_name&gt;_&lt;property_name&gt;</code>. This makes it easy to identify which fragments are defined in which modules and avoids name collisions when multiple fragments are defined in the same module.</li>
</ul>
<p>If you need to render data from multiple fragments inside the same component, you can use  <strong><code>useFragment</code></strong> multiple times:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {UserComponent_user$key} <span class="hljs-keyword">from</span> <span class="hljs-string">'UserComponent_user.graphql'</span>;
<span class="hljs-keyword">import</span> type {UserComponent_viewer$key} <span class="hljs-keyword">from</span> <span class="hljs-string">'UserComponent_viewer.graphql'</span>;

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {graphql, useFragment} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

type Props = {|
  user: UserComponent_user$key,
  <span class="hljs-attr">viewer</span>: UserComponent_viewer$key,
|};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserComponent</span>(<span class="hljs-params">props: Props</span>) </span>{
  <span class="hljs-keyword">const</span> userData = useFragment(
    graphql<span class="hljs-string">`
      fragment UserComponent_user on User {
        name
        profile_picture(scale: 2) {
          uri
        }
      }
    `</span>,
    props.user,
  );

  <span class="hljs-keyword">const</span> viewerData = useFragment(
    graphql<span class="hljs-string">`
      fragment UserComponent_viewer on Viewer {
        actor {
          name
        }
      }
    `</span>,
    props.viewer,
  );

  <span class="hljs-keyword">return</span> (
    &lt;&gt;
      &lt;h1&gt;{userData.name}&lt;/h1&gt;
      &lt;div&gt;
        &lt;img src={userData.profile_picture?.uri} /&gt;
        Acting as: {viewerData.actor?.name ?? 'Unknown'}
      &lt;/div&gt;
    &lt;/&gt;
  );
}

module.exports = UserComponent;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="composing-fragments"></a><a href="#composing-fragments" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Composing Fragments</h3>
<p>In GraphQL, fragments are reusable units, which means they can include <em>other</em> fragments, and consequently a fragment can be included within other fragments or <a href="#queries">Queries</a>:</p>
<pre><code class="hljs">fragment UserFragment on<span class="hljs-built_in"> User </span>{
  name
  age
  profile_picture(scale: 2) {
    uri
  }
  <span class="hljs-built_in">..</span>.AnotherUserFragment
}

fragment AnotherUserFragment on<span class="hljs-built_in"> User </span>{
  username
  <span class="hljs-built_in">..</span>.FooUserFragment
}
</code></pre>
<p>With Relay, you can compose fragment components in a similar way, using both component composition and fragment composition. Each React component is responsible for fetching the data dependencies of its direct children - just as it has to know about its children's props in order to render them correctly. This pattern means that developers are able to reason locally about components - what data they need, what components they render - but Relay is able to derive a global view of the data dependencies of an entire UI tree.</p>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">/**
 * UsernameSection.react.js
 *
 * Child Fragment Component
 */</span>

<span class="hljs-keyword">import</span> type {UsernameSection_user$key} <span class="hljs-keyword">from</span> <span class="hljs-string">'UsernameSection_user.graphql'</span>;

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {graphql, useFragment} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

type Props = {|
  user: UsernameSection_user$key,
|};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UsernameSection</span>(<span class="hljs-params">props: Props</span>) </span>{
  <span class="hljs-keyword">const</span> data = useFragment(
    graphql<span class="hljs-string">`
      fragment UsernameSection_user on User {
        username
      }
    `</span>,
    props.user,
  );

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{data.username ?? 'Unknown'}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}

<span class="hljs-built_in">module</span>.exports = UsernameSection;
</code></pre>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">/**
 * UserComponent.react.js
 *
 * Parent Fragment Component
 */</span>

<span class="hljs-keyword">import</span> type {UserComponent_user$key} <span class="hljs-keyword">from</span> <span class="hljs-string">'UserComponent_user.graphql'</span>;

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {graphql, useFragment} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

<span class="hljs-keyword">const</span> UsernameSection = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./UsernameSection.react'</span>);

type Props = {|
  user: UserComponent_user$key,
|};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserComponent</span>(<span class="hljs-params">props: Props</span>) </span>{
  <span class="hljs-keyword">const</span> user = useFragment(
    graphql<span class="hljs-string">`
      fragment UserComponent_user on User {
        name
        age
        profile_picture(scale: 2) {
          uri
        }

        # Include child fragment:
        ...UsernameSection_user
      }
    `</span>,
    props.user,
  );

  <span class="hljs-keyword">return</span> (
    &lt;&gt;
      &lt;h1&gt;{user.name}&lt;/h1&gt;
      &lt;div&gt;
        &lt;img src={user.profile_picture?.uri} /&gt;
        {user.age}

        {/* Render child component, passing the _fragment reference_: */}
        &lt;UsernameSection user={user}/&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}

module.exports = UserComponent;
</code></pre>
<p>There are a few things to note here:</p>
<ul>
<li><code>UserComponent</code> both renders <code>UsernameSection</code>, <em>and</em> includes the fragment declared by <code>UsernameSection</code> inside its own <code>graphql</code> fragment declaration.</li>
<li><code>UsernameSection</code> expects a <strong><em>fragment reference</em></strong> as the <code>user</code> prop. As we've mentioned before, a fragment reference is an object that Relay uses to <strong><em>read</em></strong> the data declared in the fragment definition; as you can see, the child <code>UsernameSection_user</code> fragment itself just declares fields on the <code>User</code> type, but we need to know <strong><em>which</em></strong> specific user to read those fields from; this is what the fragment reference corresponds to. In other words, a fragment reference is like <strong><em>a pointer to a specific instance of a type</em></strong> that we want to read data from.</li>
<li>Note that in this case the <code>user</code> passed to <code>UsernameSection</code>, i.e. the fragment reference, <em>doesn't actually contain any of the data declared by the child <code>UsernameSection</code> component</em>; instead, <code>UsernameSection</code> will use the fragment reference to read the data <em>it</em> declared internally, using <code>useFragment</code>. This prevents the parent from implicitly creating dependencies on data declared by its children, and vice-versa, which allows us to reason locally about our components and modify them without worrying about affecting other components. If this wasn't the case, and the parent had access to the child's data, modifying the data declared by the child could break the parent. This is known as <a href="https://relay.dev/docs/en/thinking-in-relay.html#data-masking"><strong><em>data masking</em></strong></a>.</li>
<li>The <strong><em>fragment reference</em></strong> that the child (i.e.  <code>UsernameSection</code>) expects is the result of reading a parent fragment that <em>includes</em> the child fragment. In our particular example, that means the result of reading a fragment that includes <code>...UsernameSection_user</code> will be the fragment reference that <code>UsernameSection</code> expects. In other words, the data obtained as a result of reading a fragment via <code>useFragment</code> also serves as the fragment reference for any child fragments included in that fragment.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="queries"></a><a href="#queries" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Queries</h3>
<p>A <a href="https://graphql.github.io/learn/queries/">GraphQL query</a> is a request that can be sent to a GraphQL server in combination with a set of <a href="#variables">Variables</a>, in order to fetch some data. It consists of a selection of fields, and potentially includes other fragments:</p>
<pre><code class="hljs css language-graphql">query UserQuery(<span class="hljs-variable">$id</span>: ID!) {
  user(id: <span class="hljs-variable">$id</span>) {
    id
    name
    <span class="hljs-built_in">..</span>.UserFragment
  }
  viewer {
    actor {
      name
    }
  }
}

fragment UserFragment on<span class="hljs-built_in"> User </span>{
  username
}
</code></pre>
<p>Sample response:</p>
<pre><code class="hljs css language-json">{
  <span class="hljs-attr">"data"</span>: {
    <span class="hljs-attr">"user"</span>: {
      <span class="hljs-attr">"id"</span>: <span class="hljs-string">"4"</span>,
      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Mark Zuckerberg"</span>,
      <span class="hljs-attr">"username"</span>: <span class="hljs-string">"zuck"</span>
    },
    <span class="hljs-attr">"viewer"</span>: {
      <span class="hljs-attr">"actor"</span>: {
        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Your Name"</span>
      }
    }
  }
}
</code></pre>
<p><strong><em>NOTE:</em></strong> Fragments in Relay allow declaring data dependencies for a component, but they can't be fetched by themselves; they need to be included by a query, either directly or transitively. This implies that <strong><em>all fragments must belong to a query when they are rendered</em></strong>, or in other words, they must be <em>rooted</em> under some query. Note that a single fragment can still be included by multiple queries, but when rendering a specific <em>instance</em> of a fragment component, it must have been included as part of a specific query request.</p>
<hr>
<p>To <strong><em>fetch</em></strong> <em>and</em> render a query in Relay, you can use <strong><code>useLazyLoadQuery</code></strong> Hook:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {AppQuery} <span class="hljs-keyword">from</span> <span class="hljs-string">'AppQuery.graphql'</span>;

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {graphql, useLazyLoadQuery} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> data = useLazyLoadQuery&lt;AppQuery&gt;(
    graphql<span class="hljs-string">`
      query AppQuery($id: ID!) {
        user(id: $id) {
          name
        }
      }
    `</span>,
    {<span class="hljs-attr">id</span>: <span class="hljs-string">'4'</span>},
  );

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{data.user?.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
  );
}
</code></pre>
<p>Lets see what's going on here:</p>
<ul>
<li><strong><code>useLazyLoadQuery</code></strong>  takes a <code>graphql</code> query and some variables for that query, and returns the data that was fetched for that query. The <code>variables</code> are an object containing the values for the <a href="#variables">Variables</a> referenced inside the GraphQL query.</li>
<li>Similarly to fragments, the component is automatically subscribed to updates to the query data: if the data for this query is updated anywhere in the app, the component will automatically re-render with the latest updated data.</li>
<li><code>useLazyLoadQuery</code> additionally, it takes a Flow type parameter, which corresponds to the Flow type for the query, in this case <code>AppQuery</code>.
<ul>
<li>Remember that Relay automatically generates Flow types for any declared queries, which you can import and use with <code>useLazyLoadQuery</code>. These types are available in the generated files with the following name format: <code>&lt;query_name&gt;.graphql.js</code>.</li>
<li>Note that the <code>variables</code> will checked by Flow to ensure that you are passing values that match what the GraphQL query expects.</li>
<li>Note that the <code>data</code> is already properly Flow typed without requiring an explicit annotation, and is based on the types from the GraphQL schema. For example, the type of <code>data</code> above would be: <code>{| user: ?{| name: ?string |} |}</code>.</li>
</ul></li>
<li>By default, when the component renders, Relay will automatically <strong><em>fetch</em></strong> the data for this query from the server (if it isn't already cached), and return it as a the result of the <code>useLazyLoadQuery</code> call. We'll go into more detail about how to show loading states in the <a href="#loading-states-with-suspense">Loading States With Suspense</a> section, and how Relay uses cached data in the <a href="#reusing-cached-data-for-render">Reusing Cached Data for Render</a> section.</li>
<li>Note that if you re-render your component and pass <strong><em>different query variables</em></strong> than the ones originally used, it will cause the query to be fetched again with the new variables, and potentially re-render with different data.</li>
<li>Finally, make sure you're providing a Relay environment at the root of your app before trying to render a query: <a href="#relay-environment-provider">Relay Environment Provider</a>.</li>
</ul>
<p>To fetch and render a query that includes a fragment, you can compose them in the same way fragments are composed, as shown in the <a href="#composing-fragments">Composing Fragments</a> section:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">/**
 * UserComponent.react.js
 *
 * Fragment Component
 */</span>

<span class="hljs-keyword">import</span> type {UserComponent_user$key} <span class="hljs-keyword">from</span> <span class="hljs-string">'UserComponent_user.graphql'</span>;

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {graphql, useFragment} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

type Props = {|
  user: UserComponent_user$key,
|};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserComponent</span>(<span class="hljs-params">props: Props</span>) </span>{
  <span class="hljs-keyword">const</span> data = useFragment(
    graphql<span class="hljs-string">`...`</span>,
    props.user,
  );

  <span class="hljs-keyword">return</span> (...);
}

<span class="hljs-built_in">module</span>.exports = UserComponent;
</code></pre>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">/**
 * App.react.js
 *
 * Query Component
 */</span>

<span class="hljs-keyword">import</span> type {AppQuery} <span class="hljs-keyword">from</span> <span class="hljs-string">'AppQuery.graphql'</span>;

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {graphql, useLazyLoadQuery} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

<span class="hljs-keyword">const</span> UserComponent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./UserComponent.react'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> data = useLazyLoadQuery&lt;AppQuery&gt;(
    graphql<span class="hljs-string">`
      query AppQuery($id: ID!) {
        user(id: $id) {
          name

          # Include child fragment:
          ...UserComponent_user
        }
      }
    `</span>,
    {<span class="hljs-attr">id</span>: <span class="hljs-string">'4'</span>},
  );

  <span class="hljs-keyword">return</span> (
    &lt;&gt;
      &lt;h1&gt;{data.user?.name}&lt;/h1&gt;
      {/* Render child component, passing the fragment reference: */}
      &lt;UserComponent user={data.user} /&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>Note that:</p>
<ul>
<li>The <strong><em>fragment reference</em></strong> that <code>UserComponent</code> expects is is the result of reading a parent query that includes its fragment, which in our case means a query that includes <code>...UsernameSection_user</code>. In other words, the <code>data</code> obtained as a result of <code>useLazyLoadQuery</code> also serves as the fragment reference for any child fragments included in that query.</li>
<li>As mentioned previously, <strong><em>all fragments must belong to a query when they are rendered,</em></strong> which means that all fragment components <em>must</em> be descendants of a query. This guarantees that you will always be able to provide a fragment reference for <code>useFragment</code>, by starting from the result of reading a root query with <code>useLazyLoadQuery</code>.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="variables"></a><a href="#variables" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Variables</h3>
<p>You may have noticed that the query declarations in our examples above contain references to an <code>$id</code> symbol inside the GraphQL code: these are <a href="https://graphql.github.io/learn/queries/#variables">GraphQL Variables</a>.</p>
<p>GraphQL variables are a construct that allows referencing dynamic values inside a GraphQL query. When fetching a query from the server, we also need to provide as input the actual set of values to use for the variables declared inside the query:</p>
<pre><code class="hljs css language-graphql"><span class="hljs-comment"># `$id` is a variable of type `ID!`</span>
query UserQuery($<span class="hljs-built_in">id</span>: ID!) {

  <span class="hljs-comment"># The value of `$id` is used as input to the user() call:</span>
  user(<span class="hljs-built_in">id</span>: $<span class="hljs-built_in">id</span>) {
    <span class="hljs-built_in">id</span>
    <span class="hljs-built_in">name</span>
  }
}
</code></pre>
<p>When sending a network request to fetch the query above, we need to provide both the query, and the variables to be used for this particular execution of the query. For example:</p>
<pre><code class="hljs css language-graphql"><span class="hljs-comment"># Query:</span>
query UserQuery($<span class="hljs-built_in">id</span>: ID!) {
  <span class="hljs-comment"># ...</span>
}

<span class="hljs-comment"># Variables:</span>
{<span class="hljs-string">"id"</span>: <span class="hljs-number">4</span>}
</code></pre>
<p>Fetching the above query and variables from the server would produce the following response:</p>
<pre><code class="hljs css language-javascript">{
  <span class="hljs-string">"data"</span>: {
    <span class="hljs-string">"user"</span>: {
      <span class="hljs-string">"id"</span>: <span class="hljs-string">"4"</span>,
      <span class="hljs-string">"name"</span>: <span class="hljs-string">"User 4"</span>
    }
  }
}
</code></pre>
<ul>
<li>Note that changing the value of the <code>id</code> variable used as input would of course produce a different response.</li>
</ul>
<hr>
<p>Fragments can also reference variables that have been declared by a query:</p>
<pre><code class="hljs css language-graphql">fragment UserFragment on<span class="hljs-built_in"> User </span>{
  name
  profile_picture(scale: <span class="hljs-variable">$scale</span>) {
    uri
  }
}

query ViewerQuery(<span class="hljs-variable">$scale</span>: Float!) {
  viewer {
    actor {
      <span class="hljs-built_in">..</span>.UserFragment
    }
  }
}
</code></pre>
<ul>
<li>Even though the fragment above doesn't <em>declare</em> the <code>$scale</code> variable directly, it can still reference it. Doing so makes it so any query that includes this fragment, either directly or transitively, <strong><em>must</em></strong> declare the variable and it's type, otherwise an error will be produced by the Relay compiler.</li>
<li>In other words, <strong><em>query variables are available globally by any fragment that is a descendant of the query</em></strong>.</li>
</ul>
<p>In Relay, fragment declarations inside components can also reference query variables:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserComponent</span>(<span class="hljs-params">props: Props</span>) </span>{
  <span class="hljs-keyword">const</span> data = useFragment(
    graphql<span class="hljs-string">`
    fragment UserComponent_user on User {
      name
      profile_picture(scale: $scale) {
        uri
      }
    }
    `</span>,
    props.user,
  );

  <span class="hljs-keyword">return</span> (...);
}
</code></pre>
<ul>
<li>The above fragment could be included by multiple queries, and rendered by different components, which means that any query that ends up rendering/including the above fragment <strong><em>must</em></strong> declare the <code>$scale</code> variable.</li>
<li>If any query that happens to include this fragment <em>doesn't</em> declare the <code>$scale</code> variable, an error will be produced by the Relay Compiler at build time, ensuring that an incorrect query never gets sent to the server (sending a query with missing variable declarations will also produce an error in the server).</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="arguments-and-argumentdefinitions"></a><a href="#arguments-and-argumentdefinitions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>@arguments</code> and <code>@argumentDefinitions</code></h3>
<p>However, in order to prevent bloating queries with global variable declarations, Relay also provides a way to declare variables that are scoped locally to a fragment using the <strong><code>@arguments</code></strong> and <strong><code>@argumentDefinitions</code></strong> directives:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">/**
 * Declare a fragment that accepts arguments with @argumentDefinitions
 */</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PictureComponent</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">const</span> data = useFragment(
    graphql<span class="hljs-string">`
      fragment PictureComponent_user on User
        @argumentDefinitions(scale: {type: "Float!"}) {

        # `</span>$scale<span class="hljs-string">` is a local variable here, declared above
        # as an argument `</span>scale<span class="hljs-string">`, of type `</span>Float!<span class="hljs-string">`
        profile_picture(scale: $scale) {
          uri
        }
      }
    `</span>,
    props.user,
  );
}
</code></pre>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">/**
 * Include fragment using @arguments
 */</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserComponent</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">const</span> data = useFragment(
    graphql<span class="hljs-string">`
      fragment UserComponent_user on User {
        name

        # Pass value of 2.0 for the `</span>scale<span class="hljs-string">` variable
        ...PictureComponent_user @arguments(scale: 2.0)
      }
    `</span>,
    props.user,
  );
}
</code></pre>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">/**
 * Include same fragment using _different_ @arguments
 */</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">OtherUserComponent</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">const</span> data = useFragment(
    graphql<span class="hljs-string">`
      fragment OtherUserComponent_user on User {
        name

        # Pass a different value for the scale variable.
        # The value can be another local or global variable:
        ...PictureComponent_user @arguments(scale: $pictureScale)
      }
    `</span>,
    props.user,
  );
}
</code></pre>
<ul>
<li>Note that when passing <code>@arguments</code> to a fragment, we can pass a literal value or pass another variable. The variable can be a global query variable, or another local variable declared via <code>@argumentDefinitions</code>.</li>
<li>When we actually fetch <code>PictureComponent_user</code> as part of a query, the <code>scale</code> value passed to the <code>profile_picture</code> field will depend on the argument that was provided by the parent of <code>PictureComponent_user</code>:
<ul>
<li>For <code>UserComponent_user</code> the value of <code>$scale</code> will be 2.0.</li>
<li>For <code>OtherUserComponent_user</code>, the value of <code>$scale</code> will be whatever value we pass to the server for the <code>$pictureScale</code> variable when we fetch the query.</li>
</ul></li>
</ul>
<p>Fragments that expect arguments can also declare default values, making the arguments optional:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">/**
 * Declare a fragment that accepts arguments with default values
 */</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PictureComponent</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">const</span> data = useFragment(
    graphql<span class="hljs-string">`
      fragment PictureComponent_user on User
        @argumentDefinitions(scale: {type: "Float!", defaultValue: 2.0}) {

        # `</span>$scale<span class="hljs-string">` is a local variable here, declared above
        # as an argument `</span>scale<span class="hljs-string">`, of type `</span>Float!<span class="hljs-string">` with a default value of `</span><span class="hljs-number">2.0</span><span class="hljs-string">`
        profile_picture(scale: $scale) {
          uri
        }
      }
    `</span>,
    props.user,
  );
}
</code></pre>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserComponent</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">const</span> data = useFragment(
    graphql<span class="hljs-string">`
      fragment UserComponent_user on User {
        name

        # Do not pass an argument, value for scale will be `</span><span class="hljs-number">2.0</span><span class="hljs-string">`
        ...PictureComponent_user
      }
    `</span>,
    props.user,
  );
}
</code></pre>
<ul>
<li>Not passing the argument to <code>PictureComponent_user</code> makes it use the default value for its locally declared <code>$scale</code> variable, in this case 2.0.</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="accessing-graphql-variables-at-runtime"></a><a href="#accessing-graphql-variables-at-runtime" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Accessing GraphQL Variables At Runtime</h4>
<p>If you want to access the variables that were set at the query root, the recommended approach is to pass the variables down the component tree in your application, using props, or your own application-specific context.</p>
<p>Relay currently does not expose the resolved variables (i.e. after applying argument definitions) for a specific fragment, and you should very rarely need to do so.</p>
<h3><a class="anchor" aria-hidden="true" id="loading-states-with-suspense"></a><a href="#loading-states-with-suspense" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Loading States with Suspense</h3>
<p>As you may have noticed, we mentioned that using <code>useLazyLoadQuery</code> will <strong><em>fetch</em></strong> a query from the server, but we didn't elaborate on how to render a loading UI while the query is being loaded. We will cover that in this section.</p>
<p>To render loading states while a query is being fetched, we rely on <a href="https://reactjs.org/docs/concurrent-mode-suspense.html">React Suspense</a>. Suspense is a new feature in React that allows components to interrupt or <em>&quot;suspend&quot;</em> rendering in order to wait for some asynchronous resource (such as code, images or data) to be loaded; when a component &quot;suspends&quot;, it indicates to React that the component isn't <em>&quot;ready&quot;</em> to be rendered yet, and wont be until the asynchronous resource it's waiting for is loaded. When the resource finally loads, React will try to render the component again.</p>
<p>This capability is useful for components to express asynchronous dependencies like data, code, or images that they require in order to render, and lets React coordinate rendering the loading states across a component tree as these asynchronous resources become available. More generally, the use of Suspense give us better control to implement more deliberately designed loading states when our app is loading for the first time or when it's transitioning to different states, and helps prevent accidental flickering of loading elements (such as spinners), which can commonly occur when loading sequences aren't explicitly designed and coordinated.</p>
<p>For a lot more details on Suspense, check the <a href="https://reactjs.org/docs/concurrent-mode-suspense.html">React docs on Suspense</a>.</p>
<h4><a class="anchor" aria-hidden="true" id="loading-fallbacks-with-suspense-boundaries"></a><a href="#loading-fallbacks-with-suspense-boundaries" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Loading fallbacks with Suspense Boundaries</h4>
<p>When a component is suspended, we need to render a <em>fallback</em> in place of the component while we await for it to become <em>&quot;ready&quot;</em>. In order to do so, we use the <code>Suspense</code> component provided by React:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {Suspense} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="hljs-comment">// Render a fallback using Suspense as a wrapper</span>
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">LoadingSpinner</span> /&gt;</span>}&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">CanSuspend</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span>
  );
}
</code></pre>
<p><code>Suspense</code> components can be used to wrap any component; if the target component suspends, <code>Suspense</code> will render the provided fallback until all its descendants become <em>&quot;ready&quot;</em> (i.e. until <em>all</em> of the promises thrown inside its subtree of descendants resolve). Usually, the fallback is used to render a loading state, such as a glimmer.</p>
<p>Usually, different pieces of content in our app might suspend, so we can show loading state until they are resolved by using <code>Suspense</code> :</p>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">/**
 * App.react.js
 */</span>

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {Suspense} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);

<span class="hljs-keyword">const</span> LoadingSpinner = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./LoadingSpinner.react'</span>);
<span class="hljs-keyword">const</span> MainContent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./MainContent.react'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="hljs-comment">// LoadingSpinner is rendered via the Suspense fallback</span>
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">LoadingSpinner</span> /&gt;</span>}&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">MainContent</span> /&gt;</span> {/* MainContent may suspend */}
    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span>
  );
}
</code></pre>
<p>Let's distill what's going on here:</p>
<ul>
<li>If <code>MainContent</code> suspends because it's waiting on some asynchronous resource (like data), the <code>Suspense</code> component that wraps <code>MainContent</code> will detect that it suspended, and will render the <strong><code>fallback</code></strong> element (i.e. the <code>LoadingSpinner</code> in this case) up until <code>MainContent</code> is ready to be rendered. Note that this also transitively includes descendants of <code>MainContent</code>, which might also suspend.</li>
</ul>
<p>What's nice about Suspense is that you have granular control about how to accumulate loading states for different parts of your component tree:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">/**
 * App.react.js
 */</span>

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {Suspense} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);

<span class="hljs-keyword">const</span> LoadingSpinner = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./LoadingSpinner.react'</span>);
<span class="hljs-keyword">const</span> MainContent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./MainContent.react'</span>);
<span class="hljs-keyword">const</span> SecondaryContent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./SecondaryContent.react'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="hljs-comment">// A LoadingSpinner for *_all_* content is rendered via the Suspense fallback</span>
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">LoadingSpinner</span> /&gt;</span>}&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">MainContent</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">SecondaryContent</span> /&gt;</span>  *{/* SecondaryContent can also suspend */}*
    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span>
  );
}
</code></pre>
<ul>
<li>In this case, both <code>MainContent</code> and <code>SecondaryContent</code> may suspend while they load their asynchronous resources; by wrapping both in a <code>Suspense</code>, we can show a single loading state up until they are <strong><em>all</em></strong> ready, and then render the entire content in a single paint, after everything has successfully loaded.</li>
<li>In fact, <code>MainContent</code> and <code>SecondaryContent</code> may suspend for different reasons other than fetching data, but the same <code>Suspense</code> component can be used to render a fallback up until <strong><em>all</em></strong> components in the subtree are ready to be rendered. Note that this also transitively includes descendants of <code>MainContent</code> or <code>SecondaryContent</code>, which might also suspend.</li>
</ul>
<p>Conversely, you can also decide to be more granular about your loading UI and wrap Suspense components around smaller or individual parts of your component tree:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">/**
 * App.react.js
 */</span>

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {Suspense} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);

<span class="hljs-keyword">const</span> LoadingSpinner = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./LoadingSpinner.react'</span>);
<span class="hljs-keyword">const</span> LeftColumn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./LeftHandColumn.react'</span>);
<span class="hljs-keyword">const</span> LeftColumnPlaceholder = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./LeftHandColumnPlaceholder.react'</span>);
<span class="hljs-keyword">const</span> MainContent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./MainContent.react'</span>);
<span class="hljs-keyword">const</span> SecondaryContent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./SecondaryContent.react'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      {/* Show a separate loading UI for the LeftHandColumn */}
      <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">LeftColumnPlaceholder</span> /&gt;</span>}&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">LeftColumn</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span>

      {/* Show a separate loading UI for both the Main and Secondary content */}
      <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">LoadingSpinner</span> /&gt;</span>}&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">MainContent</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">SecondaryContent</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span>
  );
}
</span></code></pre>
<ul>
<li>In this case, we're showing 2 separate loading UIs:
<ul>
<li>One to be shown until the <code>LeftColumn</code> becomes ready.</li>
<li>And one to be shown until both the <code>MainContent</code> and <code>SecondaryContent</code> become ready.</li>
</ul></li>
<li>What is powerful about this is that by more granularly wrapping our components in Suspense, <strong><em>we allow other components to be rendered earlier as they become ready</em></strong>. In our example, by separately wrapping <code>MainContent</code> and <code>SecondaryContent</code> under <code>Suspense</code>, we're allowing <code>LeftColumn</code> to render as soon as it becomes ready, which might be earlier than when the content sections become ready.</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="transitions-and-updates-that-suspend"></a><a href="#transitions-and-updates-that-suspend" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Transitions and Updates that Suspend</h4>
<p><code>Suspense</code> boundary fallbacks allow us to describe our loading states when initially rendering some content, but our applications will also have transitions between different content. Specifically, when switching between two components within an already mounted boundary, the new component you're switching to might not have loaded all of its async dependencies, which means that it will also suspend.</p>
<p>Whenever we're going to make a transition that might cause new content to suspend, we should use the <a href="https://reactjs.org/docs/concurrent-mode-patterns.html#transitions"><strong><code>useTransition</code></strong></a> to schedule the update for  transition:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> {useTransition} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TabSwitcher</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// We use startTransition to schedule the update</span>
  <span class="hljs-keyword">const</span> [startTransition] = useTransition();
  <span class="hljs-keyword">const</span> [selectedTab, setSelectedTab] = useState(<span class="hljs-string">'Home'</span>);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">LoadingGlimmer</span> /&gt;</span>}&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">MainContent</span> <span class="hljs-attr">tab</span>=<span class="hljs-string">{selectedTab}</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span>
        <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span>
          startTransition(() =&gt; {
            // Schedule an update that might suspend
            setSelectedTab('Photos');
          })
        }&gt;
        Show Photos
      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  );
}
</span></code></pre>
<p>Let's take a look at what's happening here:</p>
<ul>
<li>We have a <code>MainContent</code> component that takes a tab to render. This component might suspend while it loads the content for the current tab. During initial render, if this component suspends, we'll show the <code>LoadingGlimmer</code> fallback from the <code>Suspense</code> boundary that is wrapping it.</li>
<li>Additionally, in order to change tabs, we're keeping some state for the currently selected tab; when we set state to change the current tab, this will be an update that can cause the <code>MainContent</code> component to suspend again, since it may have to load the content for the new tab. Since this update may cause the component to suspend, <strong>we need to make sure to schedule it using the <code>startTransition</code> function we get from <code>useTransition</code></strong>. By doing so, we're letting React know that the update may suspend, so React can coordinate and render it at the right priority.</li>
</ul>
<p>However, when we make these sorts of transitions, we ideally want to avoid &quot;bad loading states&quot;, that is, loading states (e.g. a glimmer) that would replace content that has already been rendered on the screen. In this case for example, if we're already showing content for a tab, instead of immediately replacing the content with a glimmer, we might instead want to render some sort of &quot;pending&quot; or &quot;busy&quot; state to let the user know that we're changing tabs, and then render the new selected tab when it's hopefully mostly ready. In order to do so, this is where we need to take into account the different <a href="https://reactjs.org/docs/concurrent-mode-patterns.html#the-three-steps">stages</a> of a transition (<strong><em>pending</em></strong> ‚Üí <strong><em>loading</em></strong> ‚Üí <strong><em>complete</em></strong>), and make use of additional Suspense <a href="https://reactjs.org/docs/concurrent-mode-patterns.html#transitions">primitives</a>, that allow us to control what we want to show at each stage.</p>
<p>The <strong><em>pending</em></strong> stage is the first state in a transition, and is usually rendered close to the element that initiated the action (e.g. a &quot;busy spinner&quot; next to a button); it should occur immediately (at a high priority), and be rendered quickly in order to give post to the user that their action has been registered. The <strong><em>loading</em></strong> state occurs when we actually start showing the new content or the next screen; this update is usually heavier it can take a little longer, so it doesn't need to be executed at the highest priority. <em>During the <strong>loading</strong> state is where we'll show the fallbacks from our <code>Suspense</code> boundaries</em> (i.e. placeholders for the new content, like glimmers);  some of the content might be partially rendered during this stage as async resources are loaded, so it can occur in multiple steps, until we finally reach the <strong><em>complete</em></strong> state, where the full content is rendered.</p>
<p>By default, when a suspense transition occurs, if the new content suspends, React will automatically transition to the loading state and show the fallbacks from any <code>Suspense</code> boundaries that are in place for the new content.  However, if we want to delay showing the loading state, and show a <em>pending</em> state instead, we can also use <a href="https://reactjs.org/docs/concurrent-mode-patterns.html#transitions"><strong><code>useTransition</code></strong></a> to do so:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> {useTransition} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);

<span class="hljs-keyword">const</span> SUSPENSE_CONFIG = {
  <span class="hljs-comment">// timeoutMs allows us to delay showing the "loading" state for a while</span>
  <span class="hljs-comment">// in favor of showing a "pending" state that we control locally</span>
  <span class="hljs-attr">timeoutMs</span>: <span class="hljs-number">10</span> * <span class="hljs-number">1000</span>, <span class="hljs-comment">// 10 seconds</span>
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TabSwitcher</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// isPending captures the "pending" state. It will become true</span>
  <span class="hljs-comment">// **immediately** when the transition starts, and will be set back to false</span>
  <span class="hljs-comment">// when the transition reaches the fully "completed" stage (i.e. when all the</span>
  <span class="hljs-comment">// new content has fully loaded)</span>
  <span class="hljs-keyword">const</span> [startTransition, isPending] = useTransition(SUSPENSE_CONFIG);
  <span class="hljs-keyword">const</span> [selectedTab, setSelectedTab] = useState(<span class="hljs-string">'Home'</span>);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">LoadingGlimmer</span> /&gt;</span>}&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">MainContent</span> <span class="hljs-attr">tab</span>=<span class="hljs-string">{selectedTab}</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span>
        <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span>
          startTransition(() =&gt; {
            // Schedule an update that might suspend
            setSelectedTab('Photos');
          })
        }
        disabled={isPending}&gt;
        Show Photos
      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  );
}
</span></code></pre>
<blockquote>
<p><strong>NOTE:</strong> Providing a Suspense config to <code>useTransition</code> will only work as expected in <strong><em><em>React Concurrent Mode</em></em></strong></p>
</blockquote>
<p>Let's take a look at what's happening here:</p>
<ul>
<li>In this case, we're passing the <strong><code>SUSPENSE_CONFIG</code></strong> config object to <code>useTransition</code> in order to configure how we want this transition to behave. Specifically, we can pass a <strong><code>timeoutMs</code></strong> property in the config, which will dictate how long React should wait before transitioning to the <em>&quot;loading&quot;</em> state (i.e. transition to showing the fallbacks from the <code>Suspense</code> boundaries), in favor of showing a <strong><em>pending</em></strong> state controlled locally by the component during that time.</li>
<li><code>useTransition</code> will also return a <strong><code>isPending</code></strong> boolean value, which captures the pending state. That is, this value will become <code>true</code> <strong><em>immediately</em></strong> when the transition starts, and will become <code>false</code> when the transition reaches the fully <em>&quot;completed&quot;</em> stage, that is, when all the new content has been fully loaded. As mentioned above, the pending state should be used to give immediate post to the user that they're action has been received, and we can do so by using the <code>isPending</code> value to control what we render; for example, we can use that value to render a spinner next to the button, or in this case, disable the button immediately after it is clicked.</li>
</ul>
<p>For more details, check out the <a href="https://reactjs.org/docs/concurrent-mode-suspense.html">React docs on Suspense</a>.</p>
<h4><a class="anchor" aria-hidden="true" id="how-we-use-suspense-in-relay"></a><a href="#how-we-use-suspense-in-relay" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How We Use Suspense in Relay</h4>
<p><em><strong>Queries</strong></em></p>
<p>In our case, our query renderer components are components that can suspend, so we use Suspense to render loading states while a query is being fetched. Let's see what that looks like in practice:</p>
<p>Say we have the following query renderer component:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">/**
 * MainContent.react.js
 *
 * Query Component
 */</span>

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {graphql, useLazyLoadQuery} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MainContent</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// **Fetch** and render a query</span>
  <span class="hljs-keyword">const</span> data = useLazyLoadQuery&lt;...&gt;(
    graphql<span class="hljs-string">`...`</span>,
    <span class="hljs-attr">variables</span>: {...},
  );

  <span class="hljs-keyword">return</span> (...);
}
</code></pre>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">/**
 * App.react.js
 */</span>

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {Suspense} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);

<span class="hljs-keyword">const</span> LoadingSpinner = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./LoadingSpinner.react'</span>);
<span class="hljs-keyword">const</span> MainContent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./MainContent.react'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="hljs-comment">// LoadingSpinner is rendered via the Suspense fallback</span>
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">LoadingSpinner</span> /&gt;</span>}&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">MainContent</span> /&gt;</span> {/* MainContent may suspend */}
    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span>
  );
}
</code></pre>
<p>Let's distill what's going on here:</p>
<ul>
<li>We have a <code>MainContent</code> component, which is a query renderer that fetches and renders a query. <code>MainContent</code> will <em>suspend</em> rendering when it attempts to fetch the query, indicating that it isn't ready to be rendered yet, and it will resolve when the query is fetched.</li>
<li>The <code>Suspense</code>component that wraps <code>MainContent</code> will detect that <code>MainContent</code> suspended, and will render the <strong><code>fallback</code></strong> element (i.e. the <code>LoadingSpinner</code> in this case) up until <code>MainContent</code> is ready to be rendered; that is, up until the query is fetched.</li>
</ul>
<p><em><strong>Fragments</strong></em></p>
<p>Fragments are also integrated with Suspense in order to support rendering of data that's partially available in the Relay Store. For more details, check out the <a href="#rendering-partially-cached-data-highly-experimental">Rendering Partially Cached Data</a> section.</p>
<p><strong><em>Transitions</em></strong></p>
<p>Additionally, our APIs for refetching (<a href="#re-rendering-with-different-data">Re-rendering with Different Data</a>) and for <a href="#rendering-connections">Rendering Connections</a> are also integrated with Suspense; for these use cases, we are initiating Suspense transitions after initial content has been rendered, such as by refetching or paginating, which means that these transitions should also use <code>useTransition</code>. Check out those sections for more details.</p>
<h3><a class="anchor" aria-hidden="true" id="error-states-with-error-boundaries"></a><a href="#error-states-with-error-boundaries" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Error States with Error Boundaries</h3>
<p>As you may have noticed, we mentioned that using <code>useLazyLoadQuery</code> will <strong><em>fetch</em></strong> a query from the server, but we didn't elaborate on how to render UI to show an error if an error occurred during fetch. We will cover that in this section.</p>
<p>We can use <a href="https://reactjs.org/docs/error-boundaries.html"><strong>Error Boundary</strong></a> components to catch errors that occur during render (due to a network error, or any kind of error), and render an alternative error UI when that occurs. The way it works is similar to how <code>Suspense</code> works, by wrapping a component tree in an error boundary, we can specify how we want to react when an error occurs, for example by rendering a fallback UI.</p>
<p><a href="https://reactjs.org/docs/error-boundaries.html">Error boundaries</a> are simply components that implement the static <strong><code>getDerivedStateFromError</code></strong> method:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);

type State = {|error: ?<span class="hljs-built_in">Error</span>|};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;<span class="hljs-title">Props</span>, <span class="hljs-title">State</span>&gt; </span>{
  <span class="hljs-keyword">static</span> getDerivedStateFromError(error): State {
    <span class="hljs-comment">// Set some state derived from the caught error</span>
    <span class="hljs-keyword">return</span> {<span class="hljs-attr">error</span>: error};
  }
}
</code></pre>
<p>Which we can use like so:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">/**
 * App.react.js
 */</span>

<span class="hljs-keyword">const</span> ErrorBoundary = <span class="hljs-built_in">require</span>(<span class="hljs-string">'ErrorBoundary'</span>);
<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);

<span class="hljs-keyword">const</span> MainContent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./MainContent.react'</span>);
<span class="hljs-keyword">const</span> SecondaryContent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./SecondaryContent.react'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="hljs-comment">// Render an ErrorSection if an error occurs within</span>
    <span class="hljs-comment">// MainContent or Secondary Content</span>
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ErrorBoundary</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{error</span> =&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">ErrorUI</span> <span class="hljs-attr">error</span>=<span class="hljs-string">{error}</span> /&gt;</span>}&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">MainContent</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">SecondaryContent</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ErrorBoundary</span>&gt;</span>
  );
}
</span></code></pre>
<ul>
<li>We can use the Error Boundary to wrap subtrees and show a different UI when an error occurs within that subtree. When an error occurs, the specified <code>fallback</code> will be rendered instead of the content inside the boundary.</li>
<li>Note that we can also control the granularity at which we render error UIs, by wrapping components at different levels with error boundaries. In this example, if any error occurs within <code>MainContent</code> or <code>SecondaryContent</code>, we will render an <code>ErrorSection</code> in place of the entire app content.</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="retrying-after-an-error"></a><a href="#retrying-after-an-error" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Retrying after an Error</h4>
<p>In order to retry fetching a query after an error has occurred, we can attempt to re-mount the query component that produced an error:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">/**
 * ErrorBoundaryWithRetry.react.js
 */</span>

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);

type State = {|error: ?<span class="hljs-built_in">Error</span>|};

<span class="hljs-comment">// Sample ErrorBoundary that supports retrying to render the content</span>
<span class="hljs-comment">// that errored</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorBoundaryWithRetry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;<span class="hljs-title">Props</span>, <span class="hljs-title">State</span>&gt; </span>{
  state = {<span class="hljs-attr">error</span>: <span class="hljs-literal">null</span>};

  <span class="hljs-keyword">static</span> getDerivedStateFromError(error): State {
    <span class="hljs-keyword">return</span> {<span class="hljs-attr">error</span>: error};
  }

  _retry = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">this</span>.setState({<span class="hljs-attr">error</span>: <span class="hljs-literal">null</span>});
  }

  render() {
    <span class="hljs-keyword">const</span> {children, fallback} = <span class="hljs-keyword">this</span>.props;
    <span class="hljs-keyword">const</span> {error} = <span class="hljs-keyword">this</span>.state;
    <span class="hljs-keyword">if</span> (error) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fallback === <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> fallback(error, <span class="hljs-keyword">this</span>._retry);
      }
      <span class="hljs-keyword">return</span> fallback;
    }
    <span class="hljs-keyword">return</span> children;
  }
}
</code></pre>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">/**
 * App.react.js
 */</span>

<span class="hljs-keyword">const</span> ErrorBoundary = <span class="hljs-built_in">require</span>(<span class="hljs-string">'ErrorBoundary'</span>);
<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);

<span class="hljs-keyword">const</span> MainContent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./MainContent.react'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ErrorBoundaryWithRetry</span>
      <span class="hljs-attr">fallback</span>=<span class="hljs-string">{(error,</span> <span class="hljs-attr">retry</span>) =&gt;</span>
        <span class="hljs-tag">&lt;&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">ErrorUI</span> <span class="hljs-attr">error</span>=<span class="hljs-string">{error}</span> /&gt;</span>
          {/* Render a button to retry; this will attempt to re-render the
            content inside the boundary, i.e. the query component */}
          <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">onPress</span>=<span class="hljs-string">{retry}</span>&gt;</span>Retry<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
        <span class="hljs-tag">&lt;/&gt;</span>
      }&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">MainContent</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ErrorBoundaryWithRetry</span>&gt;</span>
  );
}
</span></code></pre>
<ul>
<li>The sample Error Boundary in this example code will provide a <code>retry</code> function to re-attempt to render the content that originally produced the error. By doing so, we will attempt to re-render our query component (that uses <code>useLazyLoadQuery</code>), and consequently attempt to fetch the query again.</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="accessing-errors-in-graphql-response"></a><a href="#accessing-errors-in-graphql-response" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Accessing errors in GraphQL Response</h4>
<p>By default, Relay will <strong><em>only</em></strong> surface errors to React that are returned in the top-level <a href="https://graphql.org/learn/validation/">errors field</a>, <strong>if</strong>:</p>
<ul>
<li>the fetch function provided to the <a href="https://relay.dev/docs/en/network-layer">Relay Network</a> throws or returns an Error.</li>
<li>if the top-level <code>data</code> field wasn't returned in the response.</li>
</ul>
<p>If you wish to access error information in your application to display user-friendly messages, the recommended approach is to model and expose the error information as part of your GraphQL schema.</p>
<p>For example, you could expose a field in your schema that returns either the expected result, or an Error object if an error occurred while resolving that field (instead of returning null):</p>
<pre><code class="hljs css language-graphql">type <span class="hljs-builtin-name">Error</span> {
  #<span class="hljs-built_in"> User </span>friendly message
  message: String!
}
<span class="hljs-built_in">
type </span>Foo {
  bar: Result | <span class="hljs-builtin-name">Error</span>
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="environment"></a><a href="#environment" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Environment</h3>
<h4><a class="anchor" aria-hidden="true" id="relay-environment-provider"></a><a href="#relay-environment-provider" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Relay Environment Provider</h4>
<p>In order to render Relay components, you need to render a <code>RelayEnvironmentProvider</code> component at the root of the app:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">// App root</span>

<span class="hljs-keyword">const</span> {RelayEnvironmentProvider} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Root</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">RelayEnvironmentProvider</span> <span class="hljs-attr">environment</span>=<span class="hljs-string">{environment}</span>&gt;</span>
      {...}
    <span class="hljs-tag">&lt;/<span class="hljs-name">RelayEnvironmentProvider</span>&gt;</span></span>
  );
}
</code></pre>
<ul>
<li>The <code>RelayEnvironmentProvider</code>takes an environment, which it will make available to all descendant Relay components, and which is necessary for Relay to function.</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="accessing-the-relay-environment"></a><a href="#accessing-the-relay-environment" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Accessing the Relay Environment</h4>
<p>If you want to access the <em>current</em> Relay Environment within a descendant of a <code>RelayEnvironmentProvider</code> component, you can use the <strong><code>useRelayEnvironment</code></strong> Hook:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> {useRelayEnvironment} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserComponent</span>(<span class="hljs-params">props: Props</span>) </span>{
  <span class="hljs-keyword">const</span> environment = useRelayEnvironment();

  <span class="hljs-keyword">return</span> (...);
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="reusing-cached-data-for-render"></a><a href="#reusing-cached-data-for-render" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reusing Cached Data for Render</h2>
<p>While our app is in use, Relay will accumulate and cache <em>(for some time)</em> the data for the multiple queries that have been fetched throughout usage of our app. Often times, we'll want to be able to reuse and immediately render this data that is locally cached instead of waiting for a network request when fulfilling a query; this is what we'll cover in this section.</p>
<p>Some examples of when this might be useful are:</p>
<ul>
<li>Navigating between tabs in an app, where each app renders a query. If a tab has already been visited, re-visiting the tab should render it instantly, without having to wait for a network request to fetch the data that we've already fetched before.</li>
<li>Navigating to a post that was previously rendered on a feed. If the post has already been rendered on a feed, navigating to the post's permalink page should render the post immediately, since all of the data for the post should already be cached.
<ul>
<li>Even if rendering the post in the permalink page requires more data than rendering the post on a feed, we'd still like to reuse and immediately render as much of the post's data that we already have available locally, without blocking render for the entire post if only a small bit of data is missing.</li>
</ul></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="fetch-policies"></a><a href="#fetch-policies" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fetch Policies</h3>
<p>The first step to reusing locally cached data is to specify a <strong><code>fetchPolicy</code></strong> for <code>useLazyLoadQuery</code>:</p>
<pre><code class="hljs"><span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {graphql, useLazyLoadQuery} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> data = useLazyLoadQuery&lt;AppQuery&gt;(
    graphql<span class="hljs-string">`
      query AppQuery($id: ID!) {
        user(id: $id) {
          name
        }
      }
    `</span>,
    {<span class="hljs-attr">id</span>: <span class="hljs-string">'4'</span>},
    {<span class="hljs-attr">fetchPolicy</span>: <span class="hljs-string">'store-or-network'</span>},
  );

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{data.user?.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
  );
}
</code></pre>
<p>The provided <code>fetchPolicy</code> will determine:</p>
<ul>
<li><em>if</em> the query should be fulfilled from the local cache, and</li>
<li><em>if</em> a network request should be made to fetch the query from the server, depending on the <a href="#availability-of-cached-data">availablity of the data for that query in the store</a>.</li>
</ul>
<p>By default, Relay will try to read the query from the local cache; if any piece of data for that query is <a href="#presence-of-data">missing</a> or <a href="#staleness-of-data">stale</a>, it will fetch the entire query from the network. This default <code>fetchPolicy</code> is called &quot;<strong><em>store-or-network&quot;.</em></strong></p>
<p>Specifically, <code>fetchPolicy</code> can be any of the following options:</p>
<ul>
<li><strong>&quot;store-or-network&quot;</strong>: <em>(default)</em> <strong><em>will</em></strong> reuse locally cached data and will <strong><em>only</em></strong> send a network request if any data for the query is <a href="#presence-of-data">missing</a> or <a href="#staleness-of-data">stale</a>. If the query is fully cached, a network request will <strong><em>not</em></strong> be made.</li>
<li><strong>&quot;store-and-network&quot;</strong>: <strong><em>will</em></strong> reuse locally cached data and will <strong><em>always</em></strong> send a network request, regardless of whether any data was <a href="#presence-of-data">missing</a> or <a href="#staleness-of-data">stale</a> in the store.</li>
<li><strong>&quot;network-only&quot;</strong>: <strong><em>will not</em></strong> reuse locally cached data, and will <strong><em>always</em></strong> send a network request to fetch the query, ignoring any data that might be locally cached and whether it's <a href="#presence-of-data">missing</a> or <a href="#staleness-of-data">stale</a>.</li>
<li><strong>&quot;store-only&quot;</strong>: <strong><em>will only</em></strong> reuse locally cached data, and will <strong><em>never</em></strong> send a network request to fetch the query. In this case, the responsibility of fetching the query falls to the caller, but this policy could also be used to read and operate on data that is entirely <a href="#local-data-updates">local</a>.</li>
</ul>
<p>Note that the <code>refetch</code> function discussed in the <a href="#fetching-and-rendering-different-data">Fetching More Data and Rendering Different Data</a> section  also takes a <code>fetchPolicy</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="availability-of-cached-data"></a><a href="#availability-of-cached-data" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Availability of Cached Data</h3>
<p>The behavior of the fetch policies described in the <a href="#fetch-policies">previous section</a> will depend on the availability of the data in the Relay store at the moment we attempt to evaluate a query.</p>
<p>There are 2 main aspects that determine the availability of data, which we will go over in this section:</p>
<ul>
<li><a href="#presence-of-data">Presence of data</a></li>
<li><a href="#staleness-of-data">Staleness of data</a></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="presence-of-data"></a><a href="#presence-of-data" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Presence of Data</h3>
<p>An important thing to keep in mind when attempting to reuse data that is cached in the Relay store is to understand the lifetime of that data; that is, if it is present in the store, and for how long it will be.</p>
<p>Data in the Relay store for a given query will generally be present after the query has been fetched for the first time, as long as that query is being rendered on the screen. If we‚Äôve never fetched data for a specific query, then it will be missing from the store.</p>
<p>However, even after we've fetched data for different queries, we can't keep all of the data that we've fetched indefinitely in memory, since over time it would grow to be too large and too stale. In order to mitigate this, Relay runs a process called <em>Garbage Collection</em>, in order to delete data that we're no longer using:</p>
<h4><a class="anchor" aria-hidden="true" id="garbage-collection-in-relay"></a><a href="#garbage-collection-in-relay" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Garbage Collection in Relay</h4>
<p>Specifically, Relay runs garbage collection on the local in-memory store by deleting any data that is no longer being referenced by any component in the app.</p>
<p>However, this can be at odds with reusing cached data; if the data is deleted too soon, before we try to reuse it again later, that will prevent us from reusing that data to render a screen without having to wait on a network request. To address this, this section will cover what you need to do in order to ensure that the data you want to reuse is kept cached for as long as you need it.</p>
<h5><a class="anchor" aria-hidden="true" id="query-retention"></a><a href="#query-retention" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Query Retention</h5>
<p>Retaining a query indicates to Relay that the data for that query and variables shouldn't be deleted (i.e. garbage collected). Multiple callers might retain a single query, and as long as there is at least one caller retaining a query, it won't be deleted from the store.</p>
<p>By default, any query components using useLazyLoadQuery or our other APIs will retain the query for as long as they are mounted. After they unmount, they will release the query, which means that the query might be deleted at any point in the future after that occurs.</p>
<p>If you need to retain a specific query outside of the components lifecycle, you can use the <a href="#retaining-queries"><strong><code>retain</code></strong></a> operation:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">// Retain query; this will prevent the data for this query and</span>
<span class="hljs-comment">// variables from being gabrage collected by Relay</span>
<span class="hljs-keyword">const</span> disposable = environment.retain(queryDescriptor);

<span class="hljs-comment">// Disposing of the disposable will release the data for this query</span>
<span class="hljs-comment">// and variables, meaning that it can be deleted at any moment</span>
<span class="hljs-comment">// by Relay's garbage collection if it hasn't been retained elsewhere</span>
disposable.dispose();
</code></pre>
<ul>
<li>As mentioned, this will allow you to retain the query even after a query component has unmounted, allowing other components, or future instances of the same component, to reuse the retained data.</li>
</ul>
<h5><a class="anchor" aria-hidden="true" id="controlling-relays-garbage-collection-policy"></a><a href="#controlling-relays-garbage-collection-policy" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Controlling Relay's Garbage Collection Policy</h5>
<p>There are currently 2 options you can provide to your Relay Store in to control the behavior of garbage collection:</p>
<h6><a class="anchor" aria-hidden="true" id="gc-scheduler"></a><a href="#gc-scheduler" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>GC Scheduler</h6>
<p>The <strong><code>gcScheduler</code></strong> is a function you can provide to the Relay Store which will determine when a GC execution should be scheduled to run:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">// Sample scheduler function</span>
<span class="hljs-comment">// Accepts a callback and schedules it to run at some future time.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gcScheduler</span>(<span class="hljs-params">run: (</span>) =&gt; <span class="hljs-title">void</span>) </span>{
  resolveImmediate(run);
}

<span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Store(source, {gcScheduler});
</code></pre>
<ul>
<li>By default, if a <code>gcScheduler</code> option is not provided, Relay will schedule garbage collection using the <code>resolveImmediate</code> function.</li>
<li>You can provide a scheduler function to make GC scheduling less aggressive than the default, for example based on time or <a href="https://github.com/facebook/react/tree/master/packages/scheduler">scheduler</a> priorities, or any other heuristic. By convention, implementations should not execute the callback immediately.</li>
</ul>
<h6><a class="anchor" aria-hidden="true" id="gc-release-buffer-size"></a><a href="#gc-release-buffer-size" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>GC Release Buffer Size</h6>
<p>The Relay Store internally holds a release buffer to keep a specific (configurable) number of queries temporarily retained even after they have been released by their original owner  (i.e., usually when a component rendering that query unmounts). This makes it possible (and more likely) to reuse data when navigating back to a page, tab or piece of content that has been visited before.</p>
<p>In order to configure the size of the release buffer, we can you can <strong><code>gcReleaseBufferSize</code></strong> option to the Relay Store:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Store(source, {<span class="hljs-attr">gcReleaseBufferSize</span>: <span class="hljs-number">10</span>});
</code></pre>
<ul>
<li>Note that having a buffer size of 0 is equivalent to not having the release buffer, which means that queries will be immediately released and collected.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="staleness-of-data"></a><a href="#staleness-of-data" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Staleness of Data</h3>
<p>Assuming our data is <a href="#presence-of-data">present in the store</a>, we still need to consider the staleness of such data.</p>
<p>By default, Relay will never consider data in the store to be stale (regardless of how long it has been cached for), unless it‚Äôs explicitly marked as stale using our data invalidation apis.</p>
<p>Marking data as stale is useful for cases when we explicitly know that some data is no longer fresh (for example after executing a <a href="#graphql-mutations">Mutation</a>), and we want to make sure it get‚Äôs refetched with the latest value from the server. Specifically, when data has been marked as stale, if any query references the stale data, that means the query will also be considered stale, and it will need to be fetched again the next time it is evaluated, given the provided <a href="#fetch-policies">Fetch Policy</a>.</p>
<p>Relay exposes the following APIs to mark data as stale within an update to the store:</p>
<h4><a class="anchor" aria-hidden="true" id="globally-invalidating-the-relay-store"></a><a href="#globally-invalidating-the-relay-store" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Globally Invalidating the Relay Store</h4>
<p>The coarsest type of data invalidation we can perform is invalidating the whole store, meaning that all currently cached data will be considered stale after invalidation.</p>
<p>To invalidate the store, we can call <strong><code>invalidateStore()</code></strong> within an <a href="#updater-functions">updater</a> function:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updater</span>(<span class="hljs-params">store</span>) </span>{
  store.invalidateStore();
}
</code></pre>
<ul>
<li>Calling <code>invalidateStore()</code> will cause <strong><em>all</em></strong> data that was written to the store before invalidation occurred to be considered stale, and will require any query to be refetched again the next time it‚Äôs evaluated.</li>
<li>Note that an updater function can be specified as part of a <a href="#graphql-mutations">mutation</a>, <a href="#graphql-subscriptions">subscription</a> or just a <a href="#local-data-updates">local store update</a>.</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="invalidating-specific-data-in-the-store"></a><a href="#invalidating-specific-data-in-the-store" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Invalidating Specific Data in the Store</h4>
<p>We can also be more granular about which data we invalidate and only invalidate <em>specific records</em> in the store; compared to global invalidation, only queries that reference the invalidated records will be considered stale after invalidation.</p>
<p>To invalidate a record, we can call <strong><code>invalidateRecord()</code></strong> within an <a href="#updater-functions">updater</a> function:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updater</span>(<span class="hljs-params">store</span>) </span>{
  <span class="hljs-keyword">const</span> user = store.get(<span class="hljs-string">'&lt;id&gt;'</span>);
  <span class="hljs-keyword">if</span> (user != <span class="hljs-literal">null</span>) {
    user.invalidateRecord();
  }
}
</code></pre>
<ul>
<li>Calling <code>invalidateRecord()</code> on the user record will mark <em>that</em> specific user in the store as stale. That means that any query that is cached and references that invalidated user will now be considered stale, and will require to be refetched again the next time it‚Äôs evaluated.</li>
<li>Note that an updater function can be specified as part of a <a href="#graphql-mutations">mutation</a>, <a href="#graphql-subscriptions">subscription</a> or just a <a href="#local-data-updates">local store update</a>.</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="subscribing-to-data-invalidation"></a><a href="#subscribing-to-data-invalidation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Subscribing to Data Invalidation</h4>
<p>Just marking the store or records as stale will cause queries to be refetched they next time they are evaluated; so for example, the next time you navigate back to a page that renders a stale query, the query will be refetched even if the data is cached, since the query references stale data.</p>
<p>This is useful for a lot of use cases, but there are some times when we‚Äôd like to immediately refetch some data upon invalidation, for example:</p>
<ul>
<li>When invalidating data that is already visible in the current page. Since no navigation is occurring, we won‚Äôt re-revaluate the queries for the current page, so even if some data is stale, it won't be immediately refetched and we will be showing stale data.</li>
<li>When invalidating data that is rendered on a previous view that was never unmounted; since the view wasn't unmounted, if we navigate back, the queries for that view wont be re-evaluated, meaning that even if some is stale, it won't be refetched and we will be showing stale data.</li>
</ul>
<p>To support these use cases, Relay exposes the <strong><code>useSubscribeToInvalidationState</code></strong> hook:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ProfilePage</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-comment">// Example of querying data for the current page for a given user</span>
  <span class="hljs-keyword">const</span> data = usePreloadedQuery(
    graphql<span class="hljs-string">`...`</span>,
    props.preloadedQuery,
  )

  <span class="hljs-comment">// Here we subscribe to changes in invalidation state for the given user ID.</span>
  <span class="hljs-comment">// Whenever the user whith that ID is marked as stale, the provided callback will</span>
  <span class="hljs-comment">// be executed*</span>
  useSubscribeToInvalidationState([props.userID], () =&gt; {
    <span class="hljs-comment">// Here we can do things like:</span>
    <span class="hljs-comment">// - re-evaluate the query by passing a new preloadedQuery to usePreloadedQuery.</span>
    <span class="hljs-comment">// - imperitavely refetch any data</span>
    <span class="hljs-comment">// - render a loading spinner or gray out the page to indicate that refetch</span>
    <span class="hljs-comment">//   is happening.</span>
  })

  <span class="hljs-keyword">return</span> (...);  
}
</code></pre>
<ul>
<li><code>useSubscribeToInvalidationState</code> takes an array of ids, and a callback. Whenever any of the records for those ids are marked as stale, the provided callback will fire.</li>
<li>Inside the callback, we can react accordingly and refetch and/or update any current views that are rendering stale data. As an example, we could re-execute the top-level <code>usePreloadedQuery</code> by keeping the <code>preloadedQuery</code> in state and setting a new one here; since that query is stale at that point, the query will be refetched even if the data is cached in the store.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="rendering-partially-cached-data-highly-experimental"></a><a href="#rendering-partially-cached-data-highly-experimental" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Rendering Partially Cached Data [HIGHLY EXPERIMENTAL]</h3>
<blockquote>
<p><strong>NOTE:</strong> Partial rendering behavior is still highly experimental and likely to change, and only enabled under an experimental option. If you still wish to use it, you can enable it by passing <code>{UNSTABLE_renderPolicy: &quot;partial&quot;}</code> as an option to <code>useLazyLoadQuery</code>.</p>
</blockquote>
<p>Often times when dealing with cached data, we'd like the ability to perform partial rendering. We define <em>&quot;partial rendering&quot;</em> as the ability to immediately render a query that is partially cached. That is, parts of the query might be missing, but parts of the query might already be cached. In these cases, we want to be able to immediately render the parts of the query that are cached, without waiting on the full query to be fetched.</p>
<p>This can be useful in scenarios where we want to render a screen or a page as fast as possible, and we know that some of the data for that page is already cached, so we can skip a loading state. For example, imagine a user profile page: it is very likely that the user's name has already been cached at some point during usage of the app, so when visiting a profile page, if the name of the user is cached, we'd like to render immediately, even if the rest of the data for the profile page isn't available yet.</p>
<h4><a class="anchor" aria-hidden="true" id="fragments-as-boundaries-for-partial-rendering"></a><a href="#fragments-as-boundaries-for-partial-rendering" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fragments as boundaries for partial rendering</h4>
<p>To do this, we rely on the ability of fragment containers to <a href="#loading-states-with-suspense"><em>suspend</em></a>. <strong><em>A fragment container will suspend if any of the data it declared locally is missing during render, and is currently being fetched.</em></strong> Specifically, it will suspend until the data it requires is fetched, that is, until the query it belongs to (its <em>parent query</em>) is fetched.</p>
<p>Let's explain what this means with an example. Say we have the following fragment component:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">/**
 * UsernameComponent.react.js
 *
 * Fragment Component
 */</span>

<span class="hljs-keyword">import</span> type {UsernameComponent_user$key} <span class="hljs-keyword">from</span> <span class="hljs-string">'UsernameComponent_user.graphql'</span>;

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {graphql, useFragment} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

type Props = {|
  user: UsernameComponent_user$key,
|};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UsernameComponent</span>(<span class="hljs-params">props: Props</span>) </span>{
  <span class="hljs-keyword">const</span> user = useFragment(
    graphql<span class="hljs-string">`
      fragment UsernameComponent_user on User {
        username
      }
    `</span>,
    props.user,
  );
  <span class="hljs-keyword">return</span> (...);
}

<span class="hljs-built_in">module</span>.exports = UsernameComponent;
</code></pre>
<p>And we have the following query component, which queries for some data, and also includes the fragment above:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">/**
 * App.react.js
 *
 * Query Component
 */</span>

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {graphql, useLazyLoadQuery} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

<span class="hljs-keyword">const</span> UsernameComponent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./UsernameComponent.react'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> data = useLazyLoadQuery&lt;AppQuery&gt;(
    graphql<span class="hljs-string">`
      query AppQuery($id: ID!) {
        user(id: $id) {
          name
          ...UsernameComponent_user
        }
      }
    `</span>,
    {<span class="hljs-attr">id</span>: <span class="hljs-string">'4'</span>},
    {<span class="hljs-attr">fetchPolicy</span>: <span class="hljs-string">'store-or-network'</span>},
  );

  <span class="hljs-keyword">return</span> (
    &lt;&gt;
      &lt;h1&gt;{data.user?.name}&lt;/h1&gt;
      &lt;UsernameComponent user={data.user} /&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>Say that when this <code>App</code> component is rendered, we've already previously fetched <em>(<em>only</em>)</em> the <strong><code>name</code></strong> for the <code>User</code> with <code>{id: 4}</code>, and it is locally cached in the Relay Store.</p>
<p>If we attempt to render the query with a <code>fetchPolicy</code> that allows reusing locally cached data (<code>'store-or-network'</code>, or <code>'store-and-network'</code>), the following will occur:</p>
<ul>
<li>The query will check if any of its locally required data is missing. In this case, <strong><em>it isn't</em></strong>. Specifically, the query is only directly querying for the <code>name</code>, and the name <em>is</em> available, so as far as the query is concerned, none of the data it requires to render <strong><em>itself</em></strong> is missing. This is important to keep in mind: when rendering a query, we eagerly read out data and render the tree, instead of blocking rendering of the entire tree until <em>all</em> of the data for the query (i.e. including nested fragments) is fetched. As we render, <strong><em>we will consider data to be missing for a component if the data it declared locally is missing, i.e. if any data required to render the current component is missing, and <em>not</em> if data for descendant components is missing.</em></strong></li>
<li>Given that the query doesn't have any data missing, it will render, and then attempt to render the child <code>UsernameComponent</code>.</li>
<li>When the <code>UsernameComponent</code> attempts to render the <code>UsernameComponent_user</code> fragment, it will notice that some of the data required to render itself is missing; specifically, the <strong><code>username</code></strong> is missing. At this point, since <code>UsernameComponent</code> has missing data, it will suspend rendering until the network request completes. Note that regardless of which <code>fetchPolicy</code> you choose, a network request will always be started if any piece of data for the full query, i.e. including fragments, is missing.</li>
</ul>
<p>At this point, when <code>UsernameComponent</code> suspends due to the missing <strong><code>username</code></strong>, ideally we should still be able to render the <code>User</code>'s <code>**name**</code> immediately, since it's locally cached. However, since we aren't using a <code>Suspense</code> component to catch the fragment's suspension, the suspension will bubble up and the entire <code>App</code> component will be suspended.</p>
<p>In order to achieve the desired effect of rendering the <strong><code>name</code></strong> when it's available even if the <strong><code>username</code></strong>  is missing, we just need to wrap the <code>UsernameComponent</code> in <code>Suspense,</code> to <em>allow</em> the other parts of <code>App</code> to continue rendering:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">/**
 * App.react.js
 *
 * Query Component
 */</span>

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {Suspense} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {graphql, useLazyLoadQuery} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

<span class="hljs-keyword">const</span> UsernameComponent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./UsernameComponent.react'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> data = useLazyLoadQuery&lt;AppQuery&gt;(
    graphql<span class="hljs-string">`
      query AppQuery($id: ID!) {
        user(id: $id) {
          name
          ...UsernameComponent_user
        }
      }
    `</span>,
    {<span class="hljs-attr">id</span>: <span class="hljs-string">'4'</span>},
    {<span class="hljs-attr">fetchPolicy</span>: <span class="hljs-string">'store-or-network'</span>},
  );

  <span class="hljs-keyword">return</span> (
    &lt;&gt;
      &lt;h1&gt;{data.user?.name}&lt;/h1&gt;

      {/*
        Wrap the UserComponent in Suspense to allow other parts of the
        App to be rendered even if the username is missing.
    */}
      &lt;Suspense fallback={&lt;LoadingSpinner label="Fetching username" /&gt;}&gt;
        &lt;UsernameComponent user={data.user} /&gt;
      &lt;/Suspense&gt;
    &lt;/&gt;
  );
}
</code></pre>
<hr>
<p>The process that we described above works the same way for nested fragments (i.e. fragments that include other fragments). This means that if the data required to render a fragment is locally cached, the fragment component will be able to render, regardless of whether data for any of its child or descendant fragments is missing. If data for a child fragment is missing, we can wrap it in a <code>Suspense</code> component to allow other fragments and parts of the app to continue rendering.</p>
<h3><a class="anchor" aria-hidden="true" id="filling-in-missing-data-missing-data-handlers"></a><a href="#filling-in-missing-data-missing-data-handlers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Filling in Missing Data (Missing Data Handlers)</h3>
<p>In the previous section we covered how to reuse data that is fully or partially cached, however there are cases in which Relay can't automatically tell that it can reuse some of its local data to fulfill a query. Specifically, Relay knows how to reuse data that is cached for the <em>same</em> query; that is, if you fetch the exact same query twice, Relay will know that it has the data cached for that query the second time.</p>
<p>However, when using different queries, there might still be cases where different queries point to the same data, which we'd want to be able to reuse. For example, imagine the following two queries:</p>
<pre><code class="hljs css language-graphql"><span class="hljs-comment">// Query 1</span>
<span class="hljs-selector-tag">query</span> <span class="hljs-selector-tag">UserQuery</span> {
  <span class="hljs-selector-tag">user</span>(<span class="hljs-attribute">id</span>: <span class="hljs-number">4</span>) {
    <span class="hljs-selector-tag">name</span>
  }
}
</code></pre>
<pre><code class="hljs">// Query <span class="hljs-number">2</span>
query NodeQuery {
  <span class="hljs-keyword">node</span><span class="hljs-title">(id</span>: <span class="hljs-number">4</span>) {
    ... on <span class="hljs-keyword">User</span> <span class="hljs-title">{
      name</span>
    }
  }
}
</code></pre>
<p>These two queries are different, but reference the exact same data. Ideally, if one of the queries was already cached in the store, we should be able to reuse that data when rendering the other query. However, Relay doesn't have this knowledge by default, so we need to configure it to encode the knowledge that a <code>node(id: 4)</code> <strong><em>&quot;is also a&quot;</em></strong> <code>user(id: 4)</code>.</p>
<p>To do so, we can provide <strong><code>missingFieldHandlers</code></strong> to the <code>RelayEnvironment</code>, which specify this knowledge:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> {ROOT_TYPE, Environment} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay'</span>);

<span class="hljs-keyword">const</span> missingFieldHandlers = [
  {
    handle(field, record, argValues): ?string {
      <span class="hljs-keyword">if</span> (
        record != <span class="hljs-literal">null</span> &amp;&amp;
        record.__typename === ROOT_TYPE &amp;&amp;
        field.name === <span class="hljs-string">'user'</span> &amp;&amp;
        argValues.hasOwnProperty(<span class="hljs-string">'id'</span>)
      ) {
        <span class="hljs-comment">// If field is user(id: $id), look up the record by the value of $id</span>
        <span class="hljs-keyword">return</span> argValues.id;
      }
      <span class="hljs-keyword">if</span> (
        record != <span class="hljs-literal">null</span> &amp;&amp;
        record.__typename === ROOT_TYPE &amp;&amp;
        field.name === <span class="hljs-string">'story'</span> &amp;&amp;
        argValues.hasOwnProperty(<span class="hljs-string">'story_id'</span>)
      ) {
        <span class="hljs-comment">// If field is story(story_id: $story_id), look up the record by the</span>
        <span class="hljs-comment">// value of $story_id.</span>
        <span class="hljs-keyword">return</span> argValues.story_id;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    },
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'linked'</span>,
  },
];

<span class="hljs-keyword">const</span> environment = <span class="hljs-keyword">new</span> Environment({<span class="hljs-comment">/*...*/</span>, missingFieldHandlers});
</code></pre>
<ul>
<li><code>missingFieldHandlers</code> is an array of <em>handlers</em>. Each handler must specify a <code>handle</code> function, and the kind of missing fields it knows how to handle. The 2 main types of fields that you'd want to handle are:
<ul>
<li><strong><em>'scalar'</em></strong>: This represents a field that contains a scalar value, for example a number or a string.</li>
<li><strong><em>'linked'</em></strong>: This represents a field that references another object, i.e. not a scalar.</li>
</ul></li>
<li>The <code>handle</code> function takes the field that is missing, the record that field belongs to, and any arguments that were passed to the field in the current execution of the query.
<ul>
<li>When handling a <strong><em>'scalar'</em></strong> field, the handle function should return a scalar value, in order to use as the value for a missing field</li>
<li>When handling a <strong><em>'linked'</em></strong> field, the handle function should return an <strong><em>ID</em></strong>, referencing another object in the store that should be use in place of the missing field.</li>
</ul></li>
<li>As Relay attempts to fulfill a query from the local cache, whenever it detects any missing data, it will run any of the provided missing field handlers that match the field type before definitively declaring that the data is missing.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="fetching-rendering-different-data"></a><a href="#fetching-rendering-different-data" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fetching Rendering <em>Different</em> Data</h2>
<p>After an app has been initially rendered, there are various scenarios in which you might want to fetch and render more data, re-render your UI with <em>different</em> data, or maybe refresh existing data, usually as a result of an event or user interaction.</p>
<p>In this section we'll cover some of the most common scenarios and how to build them with Relay.</p>
<h3><a class="anchor" aria-hidden="true" id="refreshing-rendered-data"></a><a href="#refreshing-rendered-data" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Refreshing Rendered Data</h3>
<p>Assuming you're not using real-time updates to update your data (e.g. using <a href="#graphql-subscriptions">GraphQL Subscriptions</a>), often times you'll want to refetch the same data you've already rendered, in order to get the latest version available on the server. This is what we'll cover in this section.</p>
<h4><a class="anchor" aria-hidden="true" id="refreshing-queries"></a><a href="#refreshing-queries" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Refreshing Queries</h4>
<p>To refresh a query, you can use the <strong><code>fetchQuery</code></strong> function described in our <a href="#fetching-queries">Fetching Queries</a> section. Specifically, you can call <code>fetchQuery</code> inside the component with the exact same query and variables. Given that the query component is subscribed to any changes in its own data, when the request completes, the component will automatically update and re-render with the latest data:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {AppQuery} <span class="hljs-keyword">from</span> <span class="hljs-string">'AppQuery.graphql'</span>;

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {graphql, useLazyLoadQuery, useRelayEnvironment, fetchQuery} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> environment = useRelayEnvironment();
  <span class="hljs-keyword">const</span> variables = {<span class="hljs-attr">id</span>: <span class="hljs-string">'4'</span>};
  <span class="hljs-keyword">const</span> appQuery = graphql<span class="hljs-string">`
    query AppQuery($id: ID!) {
      user(id: $id) {
        name
        friends {
          count
        }
      }
    }
  `</span>;

  <span class="hljs-keyword">const</span> refresh = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    fetchQuery(
      environment,
      appQuery,
      variables,
    )
    .toPromise();
  };

  <span class="hljs-keyword">const</span> data = useLazyLoadQuery&lt;AppQuery&gt;(appQuery, variables);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{data.user?.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Friends count: {data.user.friends?.count}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> refresh()}&gt;Fetch latest count<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span>
  );
}
</span></code></pre>
<p>If you want to know whether the request is in flight, in order to show a busy indicator or disable a UI control, you can subscribe to the observable returned by <code>fetchQuery</code>, and keep state in your component:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {AppQuery} <span class="hljs-keyword">from</span> <span class="hljs-string">'AppQuery.graphql'</span>;

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {useState} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {graphql, useLazyLoadQuery, useRelayEnvironment, fetchQuery} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> environment = useRelayEnvironment();
  <span class="hljs-keyword">const</span> variables = {<span class="hljs-attr">id</span>: <span class="hljs-string">'4'</span>};
  <span class="hljs-keyword">const</span> appQuery = graphql<span class="hljs-string">`
    query AppQuery($id: ID!) {
      user(id: $id) {
        name
        friends {
          count
        }
      }
    }
  `</span>;
  <span class="hljs-keyword">const</span> [isRefreshing, setIsRefreshing] = useState(<span class="hljs-literal">false</span>);

  <span class="hljs-keyword">const</span> refresh = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    fetchQuery(
      environment,
      appQuery,
      variables,
    )
    .subscribe({
      <span class="hljs-attr">start</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> setIsRefreshing(<span class="hljs-literal">true</span>),
      <span class="hljs-attr">complete</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> setIsRefreshing(<span class="hljs-literal">false</span>),
    });
  };

  <span class="hljs-keyword">const</span> data = useLazyLoadQuery&lt;AppQuery&gt;(appQuery, variables);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{data.user?.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Friends count: {data.user.friends?.count}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span>
        <span class="hljs-attr">disabled</span>=<span class="hljs-string">{isRefreshing}</span>
        <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> refetch()}&gt;
        Fetch latest count {isRefreshing ? <span class="hljs-tag">&lt;<span class="hljs-name">LoadingSpinner</span> /&gt;</span> : null}
      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span>
  );
}
</span></code></pre>
<h4><a class="anchor" aria-hidden="true" id="refreshing-fragments"></a><a href="#refreshing-fragments" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Refreshing Fragments</h4>
<p>In order to refresh the data for a fragment, we can also use <code>fetchQuery</code>, but we need to provide a query to refetch the fragment under; remember, <strong><em>fragments can't be fetched by themselves: they need to be part of a query,</em></strong> so we can't just &quot;fetch&quot; the fragment again by itself.</p>
<p>However, we don't need to manually write the query; instead, we can use the <strong><code>@refetchable</code></strong> directive, which will make it so Relay automatically generates a query to fetch the fragment when the compiler is run:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {UserComponent_user$key} <span class="hljs-keyword">from</span> <span class="hljs-string">'UserComponent_user.graphql'</span>;

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {graphql, useFragment, useRelayEnvironment} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

<span class="hljs-comment">// This query is autogenerated by Relay given @refetchable used below</span>
<span class="hljs-keyword">const</span> UserComponentUserRefreshQuery = <span class="hljs-built_in">require</span>(<span class="hljs-string">'UserComponentUserRefreshQuery.graphql'</span>);

type Props = {|
  user: UserComponent_user$key,
|};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserComponent</span>(<span class="hljs-params">props: Props</span>) </span>{
  <span class="hljs-keyword">const</span> environment = useRelayEnvironment();
  <span class="hljs-keyword">const</span> data = useFragment(
     graphql<span class="hljs-string">`
      fragment UserComponent_user on User
        # @refetchable makes it so Relay autogenerates a query for
        # fetching this fragment
        @refetchable(queryName: "UserComponentUserRefreshQuery") {
        id
        name
        friends {
          count
        }
      }
    `</span>,
    props.user,
  );

  <span class="hljs-keyword">const</span> refresh = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    fetchQuery(
      environment,
      UserComponentUserRefreshQuery,
      {<span class="hljs-attr">id</span>: data.id},
    )
    .toPromise();
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{data.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Friends count: {data.friends?.count}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> refresh()}&gt;Fetch latest count<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span>
  );
}

module.exports = UserComponent;
</span></code></pre>
<ul>
<li>Relay will autogenerate a query by adding the <code>@refetchable</code> directive to our fragment, and we can import it and pass it to <code>fetchQuery</code>. Note that <code>@refetchable</code> directive can only be added to fragments that are &quot;refetchable&quot;, that is, on fragments that are on <code>Viewer</code>, or on <code>Query</code>, or on a type that implements <code>Node</code> (i.e. a type that has an <code>id</code> field).</li>
<li>In order to fetch the query, we need to know the <code>id</code> of the user since it will be a required query variable in the generated query. To do so, we simply include the <code>id</code> in our fragment.</li>
<li>Given that the fragment container component is subscribed to any changes in its own data, when the request completes, the component will automatically update and re-render with the latest data:</li>
<li>If you want to know whether the request is in flight, in order to show a busy indicator or disable a UI control, you can use provide an <code>observer</code> to <code>fetchQuery</code>, and keep state in your component.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="re-rendering-with-different-data"></a><a href="#re-rendering-with-different-data" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Re-rendering with Different Data</h3>
<p>Often times you'll want to re-render your existing query or fragment components, but using <em>different</em> data than the one they were originally rendered with. This usually means fetching your existing queries or fragments with <em>different variables</em>.</p>
<p>Some examples of when you might want to do this:</p>
<ul>
<li>You've rendered a comment, and after user interaction want to fetch and re-render the comment body with the text translated to a different language.</li>
<li>You've rendered a profile picture, and you want to fetch and re-render it with a different size or scale.</li>
<li>You've rendered a list of search results, and you want to fetch and re-render the list with a new search term upon user input.</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="re-rendering-queries-with-different-data"></a><a href="#re-rendering-queries-with-different-data" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Re-rendering queries with different data</h4>
<p>As mentioned in the <a href="#queries">Queries</a> section, passing <strong><em>different query variables</em></strong> than the ones originally passed when using <code>useLazyLoadQuery</code> will cause the query to be fetched with the new variables, and re-render your component with the new data:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {AppQuery} <span class="hljs-keyword">from</span> <span class="hljs-string">'AppQuery.graphql'</span>;

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {useState, useTransition} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {graphql, useLazyLoadQuery} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [startTransition] = useTransition();
  <span class="hljs-keyword">const</span> [variables, setVariables] = useState({<span class="hljs-attr">id</span>: <span class="hljs-string">'4'</span>});

  <span class="hljs-keyword">const</span> data = useLazyLoadQuery&lt;AppQuery&gt;(
    graphql<span class="hljs-string">`
      query AppQuery($id: ID!) {
        user(id: $id) {
          name
        }
      }
    `</span>,
    variables,
  );

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>
        {data.user?.name}
        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span>
          <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> {
            startTransition(() =&gt; {
              setVariables({id: 'different-id'});
            });
          }}&gt;
          Fetch different User
        <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span>
  );
}
</span></code></pre>
<p>Let's distill what's going on here:</p>
<ul>
<li>Calling <code>setVariables</code> and passing a new set of variables will re-render the component and cause the query to be fetched again <strong><em>with the newly provided variables</em></strong>. In this case, we will fetch the <code>User</code> with id <code>'different-id'</code>, and render the results when they're available.</li>
<li>This will re-render your component and may cause it to suspend (as explained in (<a href="#transitions-and-updates-that-suspend">Transitions And Updates That Suspend</a>) if it needs to send and wait for a network request. If <code>setVariables</code> causes the component to suspend, you'll need to make sure that there's a <code>Suspense</code> boundary wrapping this component from above, and/or that you are using <a href="https://reactjs.org/docs/concurrent-mode-patterns.html#transitions"><code>useTransition</code></a> with a Suspense config in order to show the appropriate pending or loading state.
<ul>
<li>Note that since <code>setVariables</code> may cause the component to suspend, regardless of whether we're using a Suspense config to render a pending state, we should always use <code>startTransition</code> to schedule that update; any update that may cause a component to suspend should be scheduled using this pattern.</li>
</ul></li>
</ul>
<p>You can also provide a different <strong><code>fetchPolicy</code></strong> when refetching the query in order to specify whether to use locally cached data (as we covered in <a href="#reusing-cached-data-for-render">Reusing Cached Data for Render</a>):</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {AppQuery} <span class="hljs-keyword">from</span> <span class="hljs-string">'AppQuery.graphql'</span>;

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {useState, useTransition} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {graphql, useLazyLoadQuery} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [startTransition] = useTransition();
  <span class="hljs-keyword">const</span> [state, setState] = useState({
    <span class="hljs-attr">fetchPolicy</span>: <span class="hljs-string">'store-or-network'</span>,
    <span class="hljs-attr">variables</span>: {<span class="hljs-attr">id</span>: <span class="hljs-string">'4'</span>},
  });

  <span class="hljs-keyword">const</span> data = useLazyLoadQuery&lt;AppQuery&gt;(
    graphql<span class="hljs-string">`
      query AppQuery($id: ID!) {
        user(id: $id) {
          name
        }
      }
    `</span>,
    variables,
    {fetchPolicy},
  );

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>
        {data.user?.name}
        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span>
          <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> {
            startTransition(() =&gt; {
              setState({
                fetchPolicy: 'network-only',
                variables: {id: 'different-id'},
              });
            });
          }}&gt;
          Fetch different User
        <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span>
  );
}
</span></code></pre>
<ul>
<li>In this case, we're keeping both the <code>fetchPolicy</code> and <code>variables</code> in component state in order to trigger a refetch both with different <code>variables</code> and a different <code>fetchPolicy</code>.</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="re-rendering-fragments-with-different-data"></a><a href="#re-rendering-fragments-with-different-data" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Re-rendering Fragments with Different Data</h4>
<p>Sometimes, upon an event or user interaction, we'd like to render the <em>same</em> exact fragment that was originally rendered under the initial query, but with a different data. Conceptually, this means fetching and rendering the currently rendered fragment again, but under a new query with different variables; or in other words, <em>making the rendered fragment a new query root</em>. Remember that <strong><em>fragments can't be fetched by themselves: they need to be part of a query,</em></strong> so we can't just &quot;fetch&quot; the fragment again by itself.</p>
<p>To do so, you can use the <strong><code>useRefetchableFragment</code></strong> hook, in order to refetch a fragment under new query and variables, using the <strong><code>refetch</code></strong> function:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {CommentBodyRefetchQuery} <span class="hljs-keyword">from</span> <span class="hljs-string">'CommentBodyRefetchQuery.graphql'</span>;
<span class="hljs-keyword">import</span> type {CommentBody_comment$key} <span class="hljs-keyword">from</span> <span class="hljs-string">'CommentBody_comment.graphql'</span>;

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {useTransition} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>)
<span class="hljs-keyword">const</span> {graphql, useRefetchableFragment} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

type Props = {|
  comment: CommentBody_comment$key,
|};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CommentBody</span>(<span class="hljs-params">props: Props</span>) </span>{
  <span class="hljs-keyword">const</span> [startTransition] = useTransition();
  <span class="hljs-keyword">const</span> [data, refetch] = useRefetchableFragment&lt;CommentBodyRefetchQuery, _&gt;(
    graphql<span class="hljs-string">`
      fragment CommentBody_comment on Comment
      @refetchable(queryName: "CommentBodyRefetchQuery") {
        body(lang: $lang) {
          text
        }
      }
    `</span>,
    props.comment,
  );

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{data.body?.text}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span>
        <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> {
          startTransition(() =&gt; {
            refetch({lang: 'SPANISH'}, {fetchPolicy: 'store-or-network'});
          });
        }}&gt;
        Translate Comment
      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span>
  );
}

module.exports = CommentBody;
</span></code></pre>
<p>Let's distill what's happening in this example:</p>
<ul>
<li><code>useRefetchableFragment</code> behaves the same way as a <code>useFragment</code> (<a href="#fragments">Fragments</a>), but with a few additions:
<ul>
<li>It expects a fragment that is annotated with the <code>@refetchable</code> directive. Note that  <code>@refetchable</code> directive can only be added to fragments that are &quot;refetchable&quot;, that is, on fragments that are on <code>Viewer</code>, or on <code>Query</code>, or on a type that implements <code>Node</code> (i.e. a type that has an <code>id</code> field).</li>
<li>It returns a <strong><code>refetch</code></strong> function, which is already Flow typed to expect the query variables that the generated query expects</li>
<li>It takes to Flow type parameters: the type of the generated query (in our case  <code>CommentBodyRefetchQuery</code>), and a second type which can always be inferred, so you only need to pass underscore (<code>_</code>).</li>
</ul></li>
<li>Calling <code>refetch</code> and passing a new set of variables will fetch the fragment again <strong><em>with the newly provided variables</em></strong>. The variables you need to provide are a subset of the variables that the generated query expects; the generated query will require an <code>id</code>, if the type of the fragment has an <code>id</code> field, and any other variables that are transitively referenced in your fragment.
<ul>
<li>In this case we're passing the current comment <code>id</code> and a new value for the <code>translationType</code> variable to fetch the translated comment body.</li>
</ul></li>
<li>This will re-render your component and may cause it to suspend (as explained in <a href="#transitions-and-updates-that-suspend">Transitions And Updates That Suspend</a>) if it needs to send and wait for a network request. If <code>refetch</code> causes the component to suspend, you'll need to make sure that there's a <code>Suspense</code> boundary wrapping this component from above, and/or that you are using <a href="https://reactjs.org/docs/concurrent-mode-patterns.html#transitions"><code>useTransition</code></a> with a Suspense config in order to show the appropriate pending state.
<ul>
<li>Note that since <code>refetch</code> may cause the component to suspend, regardless of whether we're using a Suspense config to render a pending state, we should always use <code>startTransition</code> to schedule that update; any update that may cause a component to suspend should be scheduled using this pattern.</li>
</ul></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="rendering-list-data-and-pagination"></a><a href="#rendering-list-data-and-pagination" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Rendering List Data and Pagination</h2>
<p>There are several scenarios in which we'll want to query a list of data from the GraphQL server. Often times we wont want to query the <em>entire</em> set of data up front, but rather discrete sub-parts of the list, incrementally, usually in response to user input or other events. Querying a list of data in discrete parts is usually known as <a href="https://graphql.github.io/learn/pagination/">Pagination</a>.</p>
<h3><a class="anchor" aria-hidden="true" id="connections"></a><a href="#connections" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Connections</h3>
<p>Specifically in Relay, we do this via GraphQL fields known as <a href="https://graphql.github.io/learn/pagination/#complete-connection-model">Connections</a>. Connections are GraphQL fields that take a set of arguments to specify which &quot;slice&quot; of the list to query, and include in their response both the &quot;slice&quot; of the list that was requested, as well as information to indicate if there is more data available in the list and how to query it; this additional information can be used in order to perform pagination by querying for more &quot;slices&quot; or pages on the list.</p>
<p>More specifically, we perform <em>cursor-based pagination,</em> in which the input used to query for &quot;slices&quot; of the list is a <code>cursor</code> and a <code>count</code>. Cursors are essentially opaque tokens that serve as markers or pointers to a position in the list. If you're curious to learn more about the details of cursor-based pagination and connections, check out <a href="https://relay.dev/graphql/connections.htm">this spec</a>.</p>
<h3><a class="anchor" aria-hidden="true" id="rendering-connections"></a><a href="#rendering-connections" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Rendering Connections</h3>
<p>In Relay, in order to perform pagination, first you need to declare a fragment that queries for a connection:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> {graphql} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay'</span>);

<span class="hljs-keyword">const</span> userFragment = graphql<span class="hljs-string">`
  fragment UserFragment on User {
    name
    friends(after: $cursor, first: $count)
      @connection(key: "UserFragment_friends") {
      edges {
        node {
          ...FriendComponent
        }
      }
    }
  }
`</span>;
</code></pre>
<ul>
<li>In the example above, we're querying for the <code>friends</code> field, which is a connection; in other words, it adheres to the connection spec. Specifically, we can query the <code>edges</code> and <code>node</code>s in the connection; the <code>edges</code> usually contain information about the relationship between the entities, while the <code>node</code>s are the actual entities at the other end of the relationship; in this case, the <code>node</code>s are objects of type <code>User</code> representing the user's friends.</li>
<li>In order to indicate to Relay that we want to perform pagination over this connection, we need to mark the field with the <code>@connection</code> directive. We must also provide a <em>static</em> unique identifier for this connection, known as the <strong><code>key</code></strong>. We recommend the following naming convention for the connection key: <code>&lt;fragment_name&gt;_&lt;field_name&gt;</code>.</li>
<li>We will go into more detail later as to why it is necessary to mark the field as a <code>@connection</code> and give it a unique <code>key</code> in our <a href="#adding-and-removing-items-from-a-connection">Adding and Removing Items From a Connection</a> section.</li>
</ul>
<p>In order to render this fragment which queries for a connection, we can use the <strong><code>usePaginationFragment</code></strong> Hook:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {FriendsListPaginationQuery} <span class="hljs-keyword">from</span> <span class="hljs-string">'FriendsListPaginationQuery.graphql'</span>;
<span class="hljs-keyword">import</span> type {FriendsListComponent_user$key} <span class="hljs-keyword">from</span> <span class="hljs-string">'FriendsList_user.graphql'</span>;

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {Suspense, SuspenseList} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);

<span class="hljs-keyword">const</span> {graphql, usePaginationFragment} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

type Props = {|
  user: FriendsListComponent_user$key,
|};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FriendsListComponent</span>(<span class="hljs-params">props: Props</span>) </span>{
  <span class="hljs-keyword">const</span> {data} = usePaginationFragment&lt;FriendsListPaginationQuery, _&gt;(
    graphql<span class="hljs-string">`
      fragment FriendsListComponent_user on User
      @refetchable(queryName: "FriendsListPaginationQuery") {
        name
        friends(first: $count, after: $cursor)
        @connection(key: "FriendsList_user_friends") {
          edges {
            node {
              ...FriendComponent
            }
          }
        }
      }
    `</span>,
    props.user,
  );

  <span class="hljs-keyword">return</span> (
    &lt;&gt;
      &lt;h1&gt;Friends of {data.name}:&lt;/h1&gt;
      &lt;SuspenseList revealOrder="forwards"&gt;
        {/* Extract each friend from the resulting data */}
        {(data.friends?.edges ?? []).map(edge =&gt; {
          const node = edge.node;
          return (
            &lt;Suspense fallback={&lt;Glimmer /&gt;}&gt;
              &lt;FriendComponent user={node} /&gt;
            &lt;/Suspense&gt;
          );
        })}
      &lt;/SuspenseList&gt;
    &lt;/&gt;
  );
}

module.exports = FriendsListComponent;
</code></pre>
<ul>
<li><code>usePaginationFragment</code> behaves the same way as a <code>useFragment</code> (<a href="#fragments">Fragments</a>), so our list of friends is available under <strong><code>data.friends.edges.node</code></strong>, as declared by the fragment. However, it also has a few additions:
<ul>
<li>It expects a fragment that is a connection field annotated with the <code>@connection</code> directive</li>
<li>It expects a fragment that is annotated with the <code>@refetchable</code> directive. Note that  <code>@refetchable</code> directive can only be added to fragments that are &quot;refetchable&quot;, that is, on fragments that are on <code>Viewer</code>, or on <code>Query</code>, or on a type that implements <code>Node</code> (i.e. a type that has an <code>id</code> field).</li>
<li>It takes to Flow type parameters: the type of the generated query (in our case  <code>FriendsListPaginationQuery</code>), and a second type which can always be inferred, so you only need to pass underscore (<code>_</code>).</li>
</ul></li>
<li>Note that we're using <code>[SuspenseList](https://reactjs.org/docs/concurrent-mode-patterns.html#suspenselist)</code> to render the items: this will ensure that the list is rendered in order from top to bottom even if individual items in the list suspend and resolve at different times; that is, it will prevent items from rendering out of order, which prevents content from jumping around after it has been rendered.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="pagination"></a><a href="#pagination" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pagination</h3>
<p>To actually perform pagination over the connection, we need use the <strong><code>loadNext</code></strong> function to fetch the next page of items, which is available from <code>usePaginationFragment</code>:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {FriendsListPaginationQuery} <span class="hljs-keyword">from</span> <span class="hljs-string">'FriendsListPaginationQuery.graphql'</span>;
<span class="hljs-keyword">import</span> type {FriendsListComponent_user$key} <span class="hljs-keyword">from</span> <span class="hljs-string">'FriendsList_user.graphql'</span>;

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {Suspense, SuspenseList, useTransition} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);

<span class="hljs-keyword">const</span> {graphql, usePaginationFragment} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

type Props = {|
  user: FriendsListComponent_user$key,
|};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FriendsListComponent</span>(<span class="hljs-params">props: Props</span>) </span>{
  <span class="hljs-keyword">const</span> [startTransition] = useTransition();
  <span class="hljs-keyword">const</span> {data, loadNext} = usePaginationFragment&lt;FriendsListPaginationQuery, _&gt;(
    graphql<span class="hljs-string">`
      fragment FriendsListComponent_user on User
      @refetchable(queryName: "FriendsListPaginationQuery") {
        name
        friends(first: $count, after: $cursor)
        @connection(key: "FriendsList_user_friends") {
          edges {
            node {
              name
              age
            }
          }
        }
      }
    `</span>,
    props.user,
  );

  <span class="hljs-keyword">return</span> (
    &lt;&gt;
      &lt;h1&gt;Friends of {data.name}:&lt;/h1&gt;
      &lt;SuspenseList revealOrder="forwards"&gt;
        {(data.friends?.edges ?? []).map(edge =&gt; {
          const node = edge.node;
          return (
            &lt;Suspense fallback={&lt;Glimmer /&gt;}&gt;
              &lt;FriendComponent user={node} /&gt;
            &lt;/Suspense&gt;
          );
        })}
      &lt;/SuspenseList&gt;

      &lt;Button
        onClick={() =&gt; {
          startTransition(() =&gt; {
            loadNext(10)
          });
        }}&gt;
        Load more friends
      &lt;/Button&gt;
    &lt;/&gt;
  );
}

module.exports = FriendsListComponent;
</code></pre>
<p>Let's distill what's happening here:</p>
<ul>
<li><strong><code>loadNext</code></strong> takes a count to specify how many more items in the connection to fetch from the server. In this case, when <code>loadNext</code> is called we'll fetch the next 10 friends in the friends list of our currently rendered <code>User</code>.</li>
<li>When the request to fetch the next items completes, the connection will be automatically updated and the component will re-render with the latest items in the connection. In our case, this means that the <code>friends</code> field will always contain <em>all</em> of the friends that we've fetched so far. By default, <strong><em>Relay will automatically append new items to the connection upon completing a pagination request,</em></strong> and will make them available to your fragment component. If you need a different behavior, check out our <a href="#advanced-pagination-use-cases">Advanced Pagination Use Cases</a> section.</li>
<li><code>loadNext</code> may cause the component or new children components to suspend (as explained in <a href="#transitions-and-updates-that-suspend">Transitions And Updates That Suspend</a>). This means that you'll need to make sure that there's a <code>Suspense</code> boundary wrapping this component from above, and/or that you are using <a href="https://reactjs.org/docs/concurrent-mode-patterns.html#transitions"><code>useTransition</code></a> with a Suspense config in order to show the appropriate pending or loading state.
<ul>
<li>Note that since <code>loadNext</code> may cause the component to suspend, regardless of whether we're using a Suspense config to render a pending state, we should always use <code>startTransition</code> to schedule that update; any update that may cause a component to suspend should be scheduled using this pattern.</li>
</ul></li>
</ul>
<p>Often, you will also want to access information about whether there are more items available to load. To do this, you can use the <code>hasNext</code> value, also available from <code>usePaginationFragment</code>:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {FriendsListPaginationQuery} <span class="hljs-keyword">from</span> <span class="hljs-string">'FriendsListPaginationQuery.graphql'</span>;
<span class="hljs-keyword">import</span> type {FriendsListComponent_user$key} <span class="hljs-keyword">from</span> <span class="hljs-string">'FriendsList_user.graphql'</span>;

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {Suspense, SuspenseList, useTransition} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);

<span class="hljs-keyword">const</span> {graphql, usePaginationFragment} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

type Props = {|
  user: FriendsListComponent_user$key,
|};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FriendsListComponent</span>(<span class="hljs-params">props: Props</span>) </span>{
  <span class="hljs-keyword">const</span> [startTransition] = useTransition();
  <span class="hljs-keyword">const</span> {
    data,
    loadNext,
    hasNext,
  } = <span class="hljs-string">`usePaginationFragment`</span><span class="hljs-string">`&lt;`</span><span class="hljs-string">`FriendsListPaginationQuery`</span><span class="hljs-string">`,`</span><span class="hljs-string">` _`</span><span class="hljs-string">`&gt;`</span>(
    graphql<span class="hljs-string">`
      fragment FriendsListComponent_user on User
      @refetchable(queryName: "FriendsListPaginationQuery") {
        name
        friends(first: $count, after: $cursor)
        @connection(key: "FriendsList_user_friends") {
          edges {
            node {
              name
              age
            }
          }
        }
      }
    `</span>,
    props.user,
  );

  <span class="hljs-keyword">return</span> (
    &lt;&gt;
      &lt;h1&gt;Friends of {data.name}:&lt;/h1&gt;
      &lt;SuspenseList revealOrder="forwards"&gt;
        {(data.friends?.edges ?? []).map(edge =&gt; {
          const node = edge.node;
          return (
            &lt;Suspense fallback={&lt;Glimmer /&gt;}&gt;
              &lt;FriendComponent user={node} /&gt;
            &lt;/Suspense&gt;
          );
        })}
      &lt;/SuspenseList&gt;

      {/* Only render button if there are more friends to load in the list */}
      {hasNext ? (
        &lt;Button
          onClick={() =&gt; {
            startTransition(() =&gt; {
              loadNext(10)
            });
          }}&gt;
          Load more friends
        &lt;/Button&gt;
      ) : null}
    &lt;/&gt;
  );
}

module.exports = FriendsListComponent;
</code></pre>
<ul>
<li><code>hasNext</code> is a boolean which indicates if the connection has more items available. This information can be useful for determining if different UI controls should be rendered. In our specific case, we only render the <code>Button</code> if there are more friends available in the connection .</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="blocking-all-at-once-pagination"></a><a href="#blocking-all-at-once-pagination" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Blocking (&quot;all-at-once&quot;) Pagination</h3>
<p>So far when we've talked about pagination, we haven't specified how we want pagination to behave when we're rendering the new items we've fetched. Since the new items that we're fetching and rendering might individually suspend due to their own asynchronous dependencies (<a href="#loading-states-with-suspense">Loading States with Suspense</a>), we need to be able to specify what kind of behavior we want to have as we render them.</p>
<p>Usually, we've identified that this will fall under one of these 2 categories:</p>
<ul>
<li><strong><em>&quot;One by one&quot;</em></strong> (or &quot;stream-y&quot;) pagination: Regardless of whether we're actually streaming at the data layer, conceptually this type of pagination is where we want to render items one by one, in order, as they become available. In this use case, we usually want to show some sort of loading placeholder for the new items (either in aggregate or for each individual item) as they are loaded in. This should not exclude the possibility of <em>also</em> having a <em>separate</em> <a href="https://reactjs.org/docs/concurrent-mode-patterns.html#the-three-steps">pending or busy state</a> (like a spinner next to the button that started the action). This is generally the default pagination behavior that we'll want, which applies to most lists and feeds.</li>
<li><strong><em>&quot;All at once&quot;</em></strong> pagination: This type of pagination is where we want to load and render the entire next page of items <em>all at once,</em> in a <strong><em>single paint</em></strong>; that is, we want to render the next page of items only when <em>all</em> of the items are ready (including when individual items suspend). Unlike the previous case, in this case, we do not want to show individual placeholders for the new items in the list, but instead we want to immediately show a <a href="https://reactjs.org/docs/concurrent-mode-patterns.html#the-three-steps">pending or busy state</a>, such as a spinner next (or close) to the element that started the action (like a button); this pending spinner should continue &quot;spinning&quot; until the entire next page of items are <em>fully</em> loaded and rendered. The best example of this type of use case is pagination when loading new comments in a list of comments.</li>
</ul>
<p>So far in the previous pagination sections, we've implicitly been referring to the <strong><em>&quot;one by one&quot;</em></strong> pagination case when describe using <code>usePaginationFragment</code> + <code>SuspenseList</code> to render lists and show loading placeholders.</p>
<p>However, if we want to implement <strong><em>&quot;all at once&quot;</em></strong> pagination, we need to use a different API, <strong><code>useBlockingPaginationFragment</code></strong>:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {FriendsListPaginationQuery} <span class="hljs-keyword">from</span> <span class="hljs-string">'FriendsListPaginationQuery.graphql'</span>;
<span class="hljs-keyword">import</span> type {FriendsListComponent_user$key} <span class="hljs-keyword">from</span> <span class="hljs-string">'FriendsList_user.graphql'</span>;

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {useTransition, Suspense, SuspenseList} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);

<span class="hljs-keyword">const</span> {graphql, useBlockingPaginationFragment} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

type Props = {|
  user: FriendsListComponent_user$key,
|};

<span class="hljs-keyword">const</span> SUSPENSE_CONFIG = {
  <span class="hljs-comment">// timeoutMs allows us to delay showing the "loading" state for a while</span>
  <span class="hljs-comment">// in favor of showing a "pending" state that we control locally</span>
  <span class="hljs-attr">timeoutMs</span>: <span class="hljs-number">30</span> * <span class="hljs-number">1000</span>,
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FriendsListComponent</span>(<span class="hljs-params">props: Props</span>) </span>{
  <span class="hljs-comment">// isPending captures the "pending" state. It will become true</span>
  <span class="hljs-comment">// **immediately** when the pagination transition starts, and will be set back</span>
  <span class="hljs-comment">// to false when the transition reaches the fully "completed" stage</span>
  <span class="hljs-comment">// (i.e. when all the new items in the list have fully loaded and rendered)</span>
  <span class="hljs-keyword">const</span> [startTransition, isPending] = useTransition(SUSPENSE_CONFIG);
  <span class="hljs-keyword">const</span> {
    data,
    loadNext,
    hasNext,
  } = useBlockingPaginationFragment&lt;FriendsListPaginationQuery, _&gt;(
    graphql<span class="hljs-string">`
      fragment FriendsListComponent_user on User
      @refetchable(queryName: "FriendsListPaginationQuery") {
        name
        friends(first: $count, after: $cursor)
        @connection(key: "FriendsList_user_friends") {
          edges {
            node {
              name
              age
            }
          }
        }
      }
    `</span>,
    props.user,
  );

  <span class="hljs-keyword">return</span> (
    &lt;&gt;
      &lt;h1&gt;Friends of {data.name}:&lt;/h1&gt;
      &lt;SuspenseList revealOrder="forwards"&gt;
        {(data.friends?.edges ?? []).map(edge =&gt; {
          const node = edge.node;
          return (
            &lt;Suspense fallback={&lt;Glimmer /&gt;}&gt;
              &lt;FriendComponent user={node} /&gt;
            &lt;/Suspense&gt;
          );
        })}
      &lt;/SuspenseList&gt;

      {/* Render a Spinner next to the button immediately, while transition is pending */}
      {isPending ? &lt;Spinner /&gt; : null}

      {hasNext ? (
        &lt;Button
          {/* Disbale the button immediately, while transition is pending */}
          disabled={isPending}
          onClick={() =&gt; {
            startTransition(() =&gt; {
              loadNext(10)
            });
          }}&gt;
          Load more friends
        &lt;/Button&gt;
      ) : null}
    &lt;/&gt;
  );
}

module.exports = FriendsListComponent;
</code></pre>
<p>Let's distill what's going on here:</p>
<ul>
<li><code>loadNext</code> will cause the component to suspend, so we need to wrap it in <code>startTransition</code>, as explained in <a href="#transitions-and-updates-that-suspend">Transitions And Updates That Suspend</a>).</li>
<li>Also similarly to the case described in <a href="#transitions-and-updates-that-suspend">Transitions And Updates That Suspend</a>, we're passing the <strong><code>SUSPENSE_CONFIG</code></strong> config object to <code>useTransition</code> in order to configure how we want this transition to behave. Specifically, we can pass a <strong><code>timeoutMs</code></strong> property in the config, which will dictate how long React should wait before transitioning to the <em>&quot;loading&quot;</em> state (i.e. transition to showing the loading placeholders for the new items), in favor of showing a <em>&quot;pending&quot;</em> state controlled locally by the component during that time.</li>
<li><code>useTransition</code> will also return a <strong><code>isPending</code></strong> boolean value, which captures the pending state. That is, this value will become <code>true</code> <strong><em>immediately</em></strong> when the pagination transition starts, and will become <code>false</code> when the transition reaches the fully <em>&quot;completed&quot;</em> stage, that is, when all the new items have been <em>fully</em> loaded, including their own asynchronous dependencies that would cause them to suspend. We can use the <code>isPending</code> value to show immediate post to the user action, in this case by rendering a spinner next to the button and disabling the button. In this case, the spinner will be rendered and the button will be disabled until <em>all</em> the new items in the list have been fully loaded and rendered.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="using-and-changing-filters"></a><a href="#using-and-changing-filters" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using and Changing Filters</h3>
<p>Often times when querying for a list of data, you can provide different values in the query which serve as filters that change the result set, or sort it differently.</p>
<p>Some examples of this are:</p>
<ul>
<li>Building a search typeahead, where the list of results is a list filtered by the search term entered by the user.</li>
<li>Changing the ordering mode of the list comments currently displayed for a post, which could produce a completely different set of comments from the server.</li>
<li>Changing the way News Feed is ranked and sorted.</li>
</ul>
<p>Specifically, in GraphQL, connection fields can accept arguments to sort or filter the set of queried results:</p>
<pre><code class="hljs css language-graphql">fragment UserFragment on<span class="hljs-built_in"> User </span>{
  name
  friends(order_by: DATE_ADDED, search_term: <span class="hljs-string">"Alice"</span>, first: 10) {
    edges {
      node {
        name
        age
      }
    }
  }
}
</code></pre>
<p>In Relay, we can pass those arguments as usual using GraphQL <a href="#variables">Variables</a>.</p>
<pre><code class="hljs css language-javascript">type Props = {|
  user: FriendsListComponent_user$key,
|};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FriendsListComponent</span>(<span class="hljs-params">props: Props</span>) </span>{
  <span class="hljs-keyword">const</span> userRef = props.userRef;

  <span class="hljs-keyword">const</span> {data, ...} = usePaginationFragment(
    graphql<span class="hljs-string">`
      fragment FriendsListComponent_user on User {
        name
        friends(
          order_by: $orderBy,
          search_term: $searchTerm,
          after: $cursor,
          first: $count,
        ) @connection(key: "FriendsListComponent_user_friends_connection") {
          edges {
            node {
              name
              age
            }
          }
        }
      }
    `</span>,
    props.user,
  );

  <span class="hljs-keyword">return</span> (...);
}
</code></pre>
<p>When paginating, the original values for those filters will be preserved:</p>
<pre><code class="hljs css language-javascript">type Props = {|
  user: FriendsListComponent_user$key,
|};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FriendsListComponent</span>(<span class="hljs-params">props: Props</span>) </span>{
  <span class="hljs-keyword">const</span> userRef = props.userRef;

  <span class="hljs-keyword">const</span> {data, loadNext} = usePaginationFragment(
    graphql<span class="hljs-string">`
      fragment FriendsListComponent_user on User {
        name
        friends(order_by: $orderBy, search_term: $searchTerm)
          @connection(key: "FriendsListComponent_user_friends_connection") {
          edges {
            node {
              name
              age
            }
          }
        }
      }
    `</span>,
    userRef,
  );

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Friends of {data.name}:<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">List</span> <span class="hljs-attr">items</span>=<span class="hljs-string">{data.friends?.nodes}</span>&gt;</span>{...}<span class="hljs-tag">&lt;/<span class="hljs-name">List</span>&gt;</span>

      /*
       Loading the next items will use the original order_by and search_term
       values used for the initial query
    */
      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> loadNext(10)}&gt;Load more friends<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span>
  );
}
</span></code></pre>
<ul>
<li>Note that calling <code>loadNext</code> will use the <strong><em>original</em></strong> <strong><code>order_by</code></strong> and <strong><code>search_term</code></strong> values used for the initial query. During pagination, these value won't (<em>and shouldn't</em>) change.</li>
</ul>
<p>If we want to refetch the connection with <em>different</em> variables, we can use the <strong><code>refetch</code></strong> function provided by <code>usePaginationFragment</code>, similarly to how we do so when <a href="#re-rendering-fragments-with-different-data">Re-rendering Fragments With Different Data</a>:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">/**
 * FriendsListComponent.react.js
 */</span>
<span class="hljs-keyword">import</span> type {FriendsListComponent_user$ref} <span class="hljs-keyword">from</span> <span class="hljs-string">'FriendsListComponent_user.graphql'</span>;

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {useState, useEffect, useTransition, SuspenseList} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);

<span class="hljs-keyword">const</span> {graphql, usePaginationFragment} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

type Props = {|
  searchTerm?: string,
  <span class="hljs-attr">user</span>: FriendsListComponent_user$key,
|};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FriendsListComponent</span>(<span class="hljs-params">props: Props</span>) </span>{
  <span class="hljs-keyword">const</span> searchTerm = props.searchTerm;
  <span class="hljs-keyword">const</span> [startTransition] = useTransition();
  <span class="hljs-keyword">const</span> {data, loadNext, refetch} = usePaginationFragment(
    graphql<span class="hljs-string">`
      fragment FriendsListComponent_user on User {
        name
        friends(
          order_by: $orderBy,
          search_term: $searchTerm,
          after: $cursor,
          first: $count,
        ) @connection(key: "FriendsListComponent_user_friends_connection") {
          edges {
            node {
              name
              age
            }
          }
        }
      }
    `</span>,
    props.user,
  );

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// When the searchTerm provided via props changes, refetch the connection</span>
    <span class="hljs-comment">// with the new searchTerm</span>
    startTransition(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      refetch({<span class="hljs-attr">first</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">search_term</span>: searchTerm}, {<span class="hljs-attr">fetchPolicy</span>: <span class="hljs-string">'store-or-network'</span>});
    });
  }, [searchTerm]);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Friends of {data.name}:<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>

      {/* When the button is clicked, refetch the connection but sorted differently */}
      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span>
        <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span>
          startTransition(() =&gt; {
            refetch({first: 10, orderBy: 'DATE_ADDED'});
          })
        }&gt;
        Sort by date added
      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-name">SuspenseList</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">SuspenseList</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> loadNext(10)}&gt;Load more friends<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span>
  );
}
</span></code></pre>
<p>Let's distill what's going on here:</p>
<ul>
<li>Calling <strong><code>refetch</code></strong> and passing a new set of variables will fetch the fragment again <strong><em>with the newly-provided variables</em></strong>. The variables you need to provide are a subset of the variables that the generated query expects; the generated query will require an <code>id</code>, if the type of the fragment has an <code>id</code> field, and any other variables that are transitively referenced in your fragment.
<ul>
<li>In our case, we need to pass the count we want to fetch as the <code>first</code> variable, and we can pass different values for our filters, like <code>orderBy</code> or <code>searchTerm</code>.</li>
</ul></li>
<li>This will re-render your component and may cause it to suspend (as explained in <a href="#transitions-and-updates-that-suspend">Transitions And Updates That Suspend</a>) if it needs to send and wait for a network request. If <code>refetch</code> causes the component to suspend, you'll need to make sure that there's a <code>Suspense</code> boundary wrapping this component from above, and/or that you are using <a href="https://reactjs.org/docs/concurrent-mode-patterns.html#transitions"><code>useTransition</code></a> with a Suspense config in order to show the appropriate pending or loading state.
<ul>
<li>Note that since <code>refetch</code> may cause the component to suspend, regardless of whether we're using a Suspense config to render a pending state, we should always use <code>startTransition</code> to schedule that update; any update that may cause a component to suspend should be scheduled using this pattern.</li>
</ul></li>
<li>Conceptually, when we call refetch, we're fetching the connection <em>from scratch</em>. It other words, we're fetching it again from the <em>beginning</em> and <strong><em>&quot;resetting&quot;</em></strong> our pagination state. For example, if we fetch the connection with a different <code>search_term</code>, our pagination information for the previous <code>search_term</code> no longer makes sense, since we're essentially paginating over a new list of items.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="adding-and-removing-items-from-a-connection"></a><a href="#adding-and-removing-items-from-a-connection" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Adding and Removing Items From a Connection</h3>
<p>Usually when you're rendering a connection, you'll also want to be able to add or remove items to/from the connection in response to user actions.</p>
<p>As explained in our <a href="#updating-data">Updating Data</a> section, Relay holds a local in-memory store of normalized GraphQL data, where records are stored by their IDs.  When creating mutations, subscriptions, or local data updates with Relay, you must provide an <code>updater</code> function, inside which you can access and read records, as well as write and make updates to them. When records are updated, any components affected by the updated data will be notified and re-rendered.</p>
<h3><a class="anchor" aria-hidden="true" id="connection-records"></a><a href="#connection-records" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Connection Records</h3>
<p>In Relay, connection fields that are marked with the <code>@connection</code> directive are stored as special records in the store, and they hold and accumulate <em>all</em> of the items that have been fetched for the connection so far. In order to add or remove items from a connection, we need to access the connection record using the connection <strong><em><code>key</code></em></strong>, which was provided when declaring a <code>@connection</code>; specifically, this allows us to access a connection inside an <code>updater</code> function using the <code>ConnectionHandler</code> APIs.</p>
<p>For example, given the following fragment that declares a <code>@connection</code>:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> {graphql} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay'</span>);

<span class="hljs-keyword">const</span> storyFragment = graphql<span class="hljs-string">`
  fragment StoryComponent_story on Story {
    comments @connection(key: "StoryComponent_story_comments_connection") {
      nodes {
        body {
          text
        }
      }
    }
  }
`</span>;
</code></pre>
<p>We can access the connection record inside an <code>updater</code> function using <strong><code>ConnectionHandler.getConnection</code></strong>:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> {ConnectionHandler} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updater</span>(<span class="hljs-params">store: RecordSourceSelectorProxy</span>) </span>{
  <span class="hljs-keyword">const</span> storyRecord = store.get(storyID);
  <span class="hljs-keyword">const</span> connectionRecord = ConnectionHandler.getConnection(
    storyRecord,
    <span class="hljs-string">'StoryComponent_story_comments_connection'</span>,
  );

  <span class="hljs-comment">// ...</span>
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="adding-edges"></a><a href="#adding-edges" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Adding Edges</h3>
<p>Once we have a connection record, we also need a record for the new edge that we want to add to the connection. Usually, mutation or subscription payloads will contain the new edge that was added; if not, you can also construct a new edge from scratch.</p>
<p>For example, in the following mutation we can query for the newly created edge in the mutation response:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> {graphql} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay'</span>);

<span class="hljs-keyword">const</span> createCommentMutation = graphql<span class="hljs-string">`
  mutation CreateCommentMutation($input: CommentCreateData!) {
    comment_create(input: $input) {
      comment_edge {
        cursor
        node {
          body {
            text
          }
        }
      }
    }
  }
`</span>;
</code></pre>
<ul>
<li>Note that we also query for the <strong><code>cursor</code></strong> for the new edge; this isn't strictly necessary, but it is information that will be required if we need to perform pagination based on that <code>cursor</code>.</li>
</ul>
<p>Inside an <code>updater</code>, we can access the edge inside the mutation response using Relay store APIs:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> {ConnectionHandler} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updater</span>(<span class="hljs-params">store: RecordSourceSelectorProxy</span>) </span>{
  <span class="hljs-keyword">const</span> storyRecord = store.get(storyID);
  <span class="hljs-keyword">const</span> connectionRecord = ConnectionHandler.getConnection(
    storyRecord,
    <span class="hljs-string">'StoryComponent_story_comments_connection'</span>,
  );

  <span class="hljs-comment">// Get the payload returned from the server</span>
  <span class="hljs-keyword">const</span> payload = store.getRootField(<span class="hljs-string">'comment_create'</span>);

  <span class="hljs-comment">// Get the edge inside the payload</span>
  <span class="hljs-keyword">const</span> serverEdge = payload.getLinkedRecord(<span class="hljs-string">'comment_edge'</span>);

  <span class="hljs-comment">// Build edge for adding to the connection</span>
  <span class="hljs-keyword">const</span> newEdge = ConnectionHandler.buildConnectionEdge(
    store,
    connectionRecord,
    serverEdge,
  );

  <span class="hljs-comment">// ...</span>
}
</code></pre>
<ul>
<li>The mutation payload is available as a root field on that store, which can be read using the <code>store.getRootField</code> API. In our case, we're reading <code>comment_create</code>, which is the root field in the response.</li>
<li>Note that we need to construct the new edge from the edge received from the server using <strong><code>ConnectionHandler.buildConnectionEdge</code></strong> before we can add it to the connection.</li>
</ul>
<p>If you need to create a new edge from scratch, you can use <strong><code>ConnectionHandler.createEdge</code></strong>:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> {ConnectionHandler} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updater</span>(<span class="hljs-params">store: RecordSourceSelectorProxy</span>) </span>{
  <span class="hljs-keyword">const</span> storyRecord = store.get(storyID);
  <span class="hljs-keyword">const</span> connectionRecord = ConnectionHandler.getConnection(
    storyRecord,
    <span class="hljs-string">'StoryComponent_story_comments_connection'</span>,
  );

  <span class="hljs-comment">// Create a new local Comment record</span>
  <span class="hljs-keyword">const</span> id = <span class="hljs-string">`client:new_comment:<span class="hljs-subst">${randomID()}</span>`</span>;
  <span class="hljs-keyword">const</span> newCommentRecord = store.create(id, <span class="hljs-string">'Comment'</span>);

  <span class="hljs-comment">// Create new edge</span>
  <span class="hljs-keyword">const</span> newEdge = ConnectionHandler.createEdge(
    store,
    connectionRecord,
    newCommentRecord,
    <span class="hljs-string">'CommentEdge'</span>, <span class="hljs-comment">/* GraphQl Type for edge */</span>
  );

  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>Once we have a new edge record, we can add it to the the connection using <strong><code>ConnectionHandler.insertEdgeAfter</code></strong> or <strong><code>ConnectionHandler.insertEdgeBefore</code></strong>:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> {ConnectionHandler} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updater</span>(<span class="hljs-params">store: RecordSourceSelectorProxy</span>) </span>{
  <span class="hljs-keyword">const</span> storyRecord = store.get(storyID);
  <span class="hljs-keyword">const</span> connectionRecord = ConnectionHandler.getConnection(
    storyRecord,
    <span class="hljs-string">'StoryComponent_story_comments_connection'</span>,
  );

  <span class="hljs-keyword">const</span> newEdge = (...);

  <span class="hljs-comment">// Add edge to the end of the connection</span>
  ConnectionHandler.insertEdgeAfter(
    connectionRecord,
    newEdge,
  );

  <span class="hljs-comment">// Add edge to the beginning of the connection</span>
  ConnectionHandler.insertEdgeBefore(
    connectionRecord,
    newEdge,
  );
}
</code></pre>
<ul>
<li>Note that these APIs will <em>mutate</em> the connection in-place.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="removing-edges"></a><a href="#removing-edges" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Removing Edges</h3>
<p><code>ConnectionHandler</code> provides a similar API to remove an edge from a connection, via <strong><code>ConnectionHandler.deleteNode</code></strong>:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> {ConnectionHandler} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updater</span>(<span class="hljs-params">store: RecordSourceSelectorProxy</span>) </span>{
  <span class="hljs-keyword">const</span> storyRecord = store.get(storyID);
  <span class="hljs-keyword">const</span> connectionRecord = ConnectionHandler.getConnection(
    storyRecord,
    <span class="hljs-string">'StoryComponent_story_comments_connection'</span>,
  );

  <span class="hljs-comment">// Remove edge from the connection, given the ID of the node</span>
  ConnectionHandler.deleteNode(
    connectionRecord,
    commentIDToDelete,
  );
}
</code></pre>
<ul>
<li>In this case <code>ConnectionHandler.deleteNode</code> will remove an edge given a <em><strong><code>node</code></strong> ID</em>. This means it will look up which edge in the connection contains a node with the provided ID, and remove that edge.</li>
<li>Note that this API will <em>mutate</em> the connection in-place.</li>
</ul>
<blockquote>
<p><strong>Remember:</strong> When performing any of the operations described here to mutate a connection, any fragment or query components that are rendering the affected connection will be notified and re-render with the latest version of the connection.</p>
</blockquote>
<p>You can also check out our complete Relay Store APIs <a href="https://relay.dev/docs/en/relay-store.html">here</a></p>
<h3><a class="anchor" aria-hidden="true" id="connection-identity-with-filters"></a><a href="#connection-identity-with-filters" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Connection Identity With Filters</h3>
<p>In our previous examples, our connections didn't take any arguments as filters. If you declared a connection that takes arguments as filters, the values used for the filters will be part of the connection identifier. In other words, <strong><em>each of the values passed in as connection filters will be used to identify the connection in the Relay store</em></strong>, however, <strong><em>excluding</em></strong> pagination arguments; i.e. excluding:  <code>first:</code>, <code>last:</code>, <code>before:</code>, and <code>after:</code>.</p>
<p>For example, let's say the <code>comments</code> field took the following arguments, which we pass in as GraphQL <a href="#variables">Variables</a>:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> {graphql} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay'</span>);

<span class="hljs-keyword">const</span> storyFragment = graphql<span class="hljs-string">`
  fragment StoryComponent_story on Story {
    comments(
      order_by: $orderBy,
      filter_mode: $filterMode,
      language: $language,
    ) @connection(key: "StoryComponent_story_comments_connection") {
      edges {
        nodes {
          body {
            text
          }
        }
      }
    }
  }
`</span>;
</code></pre>
<p>In the example above, this means that whatever values we used for <code>$orderBy</code>, <code>$filterMode</code> and <code>$language</code> when we queried for the <code>comments</code> field will be part of the connection identifier, and we'll need to use those values when accessing the connection record from the Relay store.</p>
<p>In order to do so, we need to pass a third argument to <strong><code>ConnectionHandler.getConnection</code></strong>, with concrete filter values to identify the connection:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> {ConnectionHandler} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updater</span>(<span class="hljs-params">store: RecordSourceSelectorProxy</span>) </span>{
  <span class="hljs-keyword">const</span> storyRecord = store.get(storyID);

  <span class="hljs-comment">// Get the connection instance for the connection with comments sorted</span>
  <span class="hljs-comment">// by the date they were added</span>
  <span class="hljs-keyword">const</span> connectionRecordSortedByDate = ConnectionHandler.getConnection(
    storyRecord,
    <span class="hljs-string">'StoryComponent_story_comments_connection'</span>,
    {<span class="hljs-attr">order_by</span>: <span class="hljs-string">'DATE_ADDED'</span>, <span class="hljs-attr">filter_mode</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">language</span>: <span class="hljs-literal">null</span>}
  );

  <span class="hljs-comment">// Get the connection instance for the connection that only contains</span>
  <span class="hljs-comment">// comments made by friends</span>
  <span class="hljs-keyword">const</span> connectionRecordFriendsOnly = ConnectionHandler.getConnection(
    storyRecord,
    <span class="hljs-string">'StoryComponent_story_comments_connection'</span>,
    {<span class="hljs-attr">order_by</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">filter_mode</span>: <span class="hljs-string">'FRIENDS_ONLY'</span>, <span class="hljs-attr">langugage</span>: <span class="hljs-literal">null</span>}
  );
}
</code></pre>
<p>This implies that by default, <strong><em>each combination of values used for filters will produce a different record for the connection.</em></strong></p>
<p>When making updates to a connection, you will need to make sure to update all of the relevant records affected by a change. For example, if we were to add a new comment to our example connection, we'd need to make sure <strong><em>not</em></strong> to add the comment to the <code>FRIENDS_ONLY</code> connection, if the new comment wasn't made by a friend of the user:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> {ConnectionHandler} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updater</span>(<span class="hljs-params">store: RecordSourceSelectorProxy</span>) </span>{
  <span class="hljs-keyword">const</span> storyRecord = store.get(storyID);

  <span class="hljs-comment">// Get the connection instance for the connection with comments sorted</span>
  <span class="hljs-comment">// by the date they were added</span>
  <span class="hljs-keyword">const</span> connectionRecordSortedByDate = ConnectionHandler.getConnection(
    storyRecord,
    <span class="hljs-string">'StoryComponent_story_comments_connection'</span>,
    {<span class="hljs-attr">order_by</span>: <span class="hljs-string">'*DATE_ADDED*'</span>, <span class="hljs-attr">filter_mode</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">language</span>: <span class="hljs-literal">null</span>}
  );

  <span class="hljs-comment">// Get the connection instance for the connection that only contains</span>
  <span class="hljs-comment">// comments made by friends</span>
  <span class="hljs-keyword">const</span> connectionRecordFriendsOnly = ConnectionHandler.getConnection(
    storyRecord,
    <span class="hljs-string">'StoryComponent_story_comments_connection'</span>,
    {<span class="hljs-attr">order_by</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">filter_mode</span>: <span class="hljs-string">'*FRIENDS_ONLY*'</span>, <span class="hljs-attr">language</span>: <span class="hljs-literal">null</span>}
  );

  <span class="hljs-keyword">const</span> newComment = (...);
  <span class="hljs-keyword">const</span> newEdge = (...);

  ConnectionHandler.insertEdgeAfter(
    connectionRecordSortedByDate,
    newEdge,
  );

  <span class="hljs-keyword">if</span> (isMadeByFriend(storyRecord, newComment) {
    <span class="hljs-comment">// Only add new comment to friends-only connection if the comment</span>
    <span class="hljs-comment">// was made by a friend</span>
    ConnectionHandler.insertEdgeAfter(
      connectionRecordFriendsOnly,
      newEdge,
    );
  }
}
</code></pre>
<p><em><strong>Managing connections with many filters:</strong></em></p>
<p>As you can see, just adding a few filters to a connection can make the complexity and number of connection records that need to be managed explode. In order to more easily manage this, Relay provides 2 strategies:</p>
<ol>
<li>Specify exactly <em>which</em> filters should be used as connection identifiers.</li>
</ol>
<p>By default, <strong><em>all</em></strong> <strong>non-pagination</strong> filters will be used as part of the connection identifier. However, when declaring a <code>@connection</code>, you can specify the exact set of filters to use for connection identity:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> {graphql} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay'</span>);

<span class="hljs-keyword">const</span> storyFragment = graphql<span class="hljs-string">`
  fragment StoryComponent_story on Story {
    comments(
      order_by: $orderBy
      filter_mode: $filterMode
      language: $language
    )
      @connection(
        key: "StoryComponent_story_comments_connection"
        filters: ["order_by", "filter_mode"]
      ) {
      edges {
        nodes {
          body {
            text
          }
        }
      }
    }
  }
`</span>;
</code></pre>
<ul>
<li>By specifying <code>filters</code> when declaring the <code>@connection</code>, we're indicating to Relay the exact set of filter values that should be used as part of connection identity. In this case, we're excluding <code>language</code>, which means that only values for <code>order_by</code> and <code>filter_mode</code> will affect connection identity and thus produce new connection records.</li>
<li>Conceptually, this means that we're specifying which arguments affect the output of the connection from the server, or in other words, which arguments are <em>actually</em> <strong><em>filters</em></strong>. If one of the connection arguments doesn't actually change the set of items that are returned from the server, or their ordering, then it isn't really a filter on the connection, and we don't need to identify the connection differently when that value changes. In our example, changing the <code>language</code> of the comments we request doesn't change the set of comments that are returned by the connection, so it is safe to exclude it from <code>filters</code>.</li>
<li>This can also be useful if we know that any of the connection arguments will never change in our app, in which case it would also be safe to exclude from <code>filters</code>.</li>
</ul>
<ol start="2">
<li>An easier API alternative to manage multiple connections with multiple filter values is still pending</li>
</ol>
<blockquote>
<p><strong>TODO</strong></p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="advanced-pagination-use-cases"></a><a href="#advanced-pagination-use-cases" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Advanced Pagination Use Cases</h3>
<p>In this section we're going to cover how to implement more advanced pagination use cases than the default cases covered by <code>usePaginationFragment</code>.</p>
<h4><a class="anchor" aria-hidden="true" id="pagination-over-multiple-connections"></a><a href="#pagination-over-multiple-connections" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pagination Over Multiple Connections</h4>
<p>If you need to paginate over multiple connections within the same component, you can use <code>usePaginationFragment</code> multiple times:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {CombinedFriendsListComponent_user$key} <span class="hljs-keyword">from</span> <span class="hljs-string">'CombinedFriendsListComponent_user.graphql'</span>;
<span class="hljs-keyword">import</span> type {CombinedFriendsListComponent_viewer$key} <span class="hljs-keyword">from</span> <span class="hljs-string">'CombinedFriendsListComponent_viewer.graphql'</span>;

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);

<span class="hljs-keyword">const</span> {graphql, usePaginationFragment} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

type Props = {|
  user: CombinedFriendsListComponent_user$key,
  <span class="hljs-attr">viewer</span>: CombinedFriendsListComponent_viewer$key,
|};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CombinedFriendsListComponent</span>(<span class="hljs-params">props: Props</span>) </span>{

  <span class="hljs-keyword">const</span> {<span class="hljs-attr">data</span>: userData, ...userPagination} = usePaginationFragment(
    graphql<span class="hljs-string">`
      fragment CombinedFriendsListComponent_user on User {
        name
        friends
          @connection(
            key: "CombinedFriendsListComponent_user_friends_connection"
          ) {
          edges {
            node {
              name
              age
            }
          }
        }
      }
    `</span>,
    props.user,
  );

  <span class="hljs-keyword">const</span> {<span class="hljs-attr">data</span>: viewerData, ...viewerPagination} = usePaginationFragment(
    graphql<span class="hljs-string">`
      fragment CombinedFriendsListComponent_user on Viewer {
        actor {
          ... on User {
            name
            friends
              @connection(
                key: "CombinedFriendsListComponent_viewer_friends_connection"
              ) {
              edges {
                node {
                  name
                  age
                }
              }
            }
          }
        }
      }
    `</span>,
    props.viewer,
  );

  <span class="hljs-keyword">return</span> (...);
}
</code></pre>
<p>However, we recommend trying to keep a single connection per component, to keep the components easier to follow.</p>
<h4><a class="anchor" aria-hidden="true" id="bi-directional-pagination"></a><a href="#bi-directional-pagination" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Bi-directional Pagination</h4>
<p>In the <a href="#pagination">Pagination</a> section we covered how to use <code>usePaginationFragment</code> to paginate in a single <em>&quot;forward&quot;</em> direction. However, connections also allow paginating in the opposite <em>&quot;backward&quot;</em> direction. The meaning of <em>&quot;forward&quot;</em> and <em>&quot;backward&quot;</em> directions will depend on how the items in the connection are sorted, for example  <em>&quot;forward&quot;</em> could mean more recent, and <em>&quot;backward&quot;</em> could mean less recent.</p>
<p>Regardless of the semantic meaning of the direction, Relay also provides the same APIs to paginate in the opposite direction using <strong><code>usePaginationFragment</code></strong>, as long  as the <strong><code>before</code></strong> and <strong><code>last</code></strong> connection arguments are also used along with <code>after</code> and <code>first</code>:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {FriendsListComponent_user$key} <span class="hljs-keyword">from</span> <span class="hljs-string">'FriendsListComponent_user.graphql'</span>;

<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);
<span class="hljs-keyword">const</span> {Suspense} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'React'</span>);

<span class="hljs-keyword">const</span> {graphql, usePaginationFragment} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

type Props = {|
  userRef: FriendsListComponent_user$key,
|};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FriendsListComponent</span>(<span class="hljs-params">props: Props</span>) </span>{
  <span class="hljs-keyword">const</span> {
    data,
    loadPrevious,
    hasPrevious,
    <span class="hljs-comment">// ... forward pagination values</span>
  } = usePaginationFragment(
    graphql<span class="hljs-string">`
      fragment FriendsListComponent_user on User {
        name
        friends(after: $after, before: $before, first: $first, last: $last)
          @connection(key: "FriendsListComponent_user_friends_connection") {
          edges {
            node {
              name
              age
            }
          }
        }
      }
    `</span>,
    userRef,
  );

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Friends of {data.name}:<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">List</span> <span class="hljs-attr">items</span>=<span class="hljs-string">{data.friends?.edges.map(edge</span> =&gt;</span> edge.node)}&gt;
        {node =&gt; {
          return (
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
              {node.name} - {node.age}
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          );
        }}
      <span class="hljs-tag">&lt;/<span class="hljs-name">List</span>&gt;</span>

      {hasPrevious ? (
        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> loadPrevious(10)}&gt;
          Load more friends
        <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
      ) : null}

      {/* Forward pagination controls can go simultaneously here */}
    <span class="hljs-tag">&lt;/&gt;</span>
  );
}

</span></code></pre>
<ul>
<li>The APIs for both <em>&quot;forward&quot;</em> and <em>&quot;backward&quot;</em> are exactly the same, they're only named differently. When paginating forward, then the  <code>after</code> and <code>first</code> connection arguments will be used, when paginating backward, the <code>before</code> and <code>last</code> connection arguments will be used.</li>
<li>Note that the primitives for both <em>&quot;forward&quot;</em> and <em>&quot;backward&quot;</em> pagination are exposed from a single use of <code>usePaginationFragment</code> call, so both <em>&quot;forward&quot;</em> and <em>&quot;backward&quot;</em> pagination can be performed simultaneously in the same component.</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="custom-connection-state"></a><a href="#custom-connection-state" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Custom Connection State</h4>
<p>By default, when using <code>usePaginationFragment</code> and <code>@connection</code>, Relay will <em>append</em> new pages of items to the connection when paginating <em>&quot;forward&quot;,</em> and <em>prepend</em> new pages of items when paginating <em>&quot;backward&quot;</em>. This means that your component will always render the <strong><em>full</em></strong> connection, with <em>all</em> of the items that have been accumulated so far via pagination, and/or items that have been added or removed via mutations or subscriptions.</p>
<p>However, it is possible that you'd need different behavior for how to merge and accumulate pagination results (or other updates to the connection), and/or derive local component state from changes to the connection. Some examples of this might be:</p>
<ul>
<li>Keeping track of different <em>visible</em> slices or windows of the connection.</li>
<li>Visually separating each <em>page</em> of items. This requires knowledge of the exact set of items inside each page that has been fetched.</li>
<li>Displaying different ends of the same connection simultaneously, while keeping track of the &quot;gaps&quot; between them, and being able to merge results when preforming pagination between the gaps. For example, imagine rendering a list of comments where the oldest comments are displayed at the top, then a &quot;gap&quot; that can be interacted with to paginate, and then a section at the bottom which shows the most recent comments that have been added by the user or by real-time subscriptions.</li>
</ul>
<p>To address these more complex use cases, Relay is still working on a solution:</p>
<blockquote>
<p><strong>TODO</strong></p>
</blockquote>
<h4><a class="anchor" aria-hidden="true" id="refreshing-connections"></a><a href="#refreshing-connections" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Refreshing connections</h4>
<blockquote>
<p><strong>TODO</strong></p>
</blockquote>
<h4><a class="anchor" aria-hidden="true" id="prefetching-pages-of-a-connection"></a><a href="#prefetching-pages-of-a-connection" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Prefetching Pages of a Connection</h4>
<blockquote>
<p><strong>TODO</strong></p>
</blockquote>
<h4><a class="anchor" aria-hidden="true" id="rendering-one-page-of-items-at-a-time"></a><a href="#rendering-one-page-of-items-at-a-time" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Rendering One Page of Items at a Time</h4>
<blockquote>
<p><strong>TODO</strong></p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="advanced-data-fetching"></a><a href="#advanced-data-fetching" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Advanced Data Fetching</h2>
<h3><a class="anchor" aria-hidden="true" id="preloading-data"></a><a href="#preloading-data" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Preloading Data</h3>
<h4><a class="anchor" aria-hidden="true" id="preloading-data-for-initial-load-server-preloading"></a><a href="#preloading-data-for-initial-load-server-preloading" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Preloading Data for Initial Load (Server Preloading)</h4>
<blockquote>
<p>OSS TODO</p>
</blockquote>
<h4><a class="anchor" aria-hidden="true" id="preloading-data-for-transitions-in-parallel-with-code-client-preloading"></a><a href="#preloading-data-for-transitions-in-parallel-with-code-client-preloading" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Preloading Data for Transitions, in Parallel With Code (Client Preloading)</h4>
<p>The way navigations or transitions into different pages work by default is the following:</p>
<ul>
<li><em>first</em>, we load the code necessary to render that new page, since that will usually correspond to a separate JS bundle.</li>
<li>*then, once the code for the new page is loaded, we can start rendering it, and only at that point when we start rendering the page do we send a network request to fetch the data that the page needs, for example by using <code>useLazyLoadQuery</code> (<a href="#queries">Queries</a>).</li>
</ul>
<p>This not only applies to transitions to other pages, but also for displaying elements such as dialogs, menus, popovers, or other elements that are hidden behind some user interaction, and which have both code <em>and</em> data dependencies.</p>
<p>The problem with this naive approach is that we have to wait for a significant amount of time before we can actually start fetching the data we need. Ideally, by the time a user interaction occurs, we'd already know what data we will need in order to fulfill that interaction, and we could start <em>preloading</em> it from the client immediately, <strong><em>in parallel</em></strong> with loading the JS code that we're going to need; by doing so, we can significantly speed up the amount of time it takes to show content to users after an interaction.</p>
<p>In order to do so, we can use <strong>Relay EntryPoints</strong>, which are a set of APIs for efficiently loading both the code and data dependencies of <em>any</em> view in parallel. Check out our api reference for Entry Points: <TODO></p>
<h3><a class="anchor" aria-hidden="true" id="incremental-data-delivery"></a><a href="#incremental-data-delivery" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Incremental Data Delivery</h3>
<blockquote>
<p>OSS TODO</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="data-driven-dependencies"></a><a href="#data-driven-dependencies" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Data-driven Dependencies</h3>
<blockquote>
<p>OSS TODO</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="image-prefetching"></a><a href="#image-prefetching" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Image Prefetching</h3>
<p>The standard approach to loading images with Relay is to first request image URIs via a Relay fragment, then render an appropriate image component with the resulting URI as the source. With this approach the image is only downloaded if it is actually rendered, which is often a good tradeoff as it avoids fetching images that aren't used. However, there are some cases where a product knows statically that it will render an image, and in this case performance can be improved by downloading the image as early as possible. Relay <strong>image prefetching</strong> allows products to specify that specific image URLs be downloaded as early as possible - as soon as the GraphQL data is fetched - without waiting for the consuming component to actually render.</p>
<h4><a class="anchor" aria-hidden="true" id="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h4>
<blockquote>
<p>OSS TODO</p>
</blockquote>
<h4><a class="anchor" aria-hidden="true" id="when-to-use-image-prefetching"></a><a href="#when-to-use-image-prefetching" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>When To Use Image Prefetching</h4>
<p>We recommend only using preloading for images that will be unconditionally rendered to the DOM by your components soon after being fetched, and avoid prefetching images that are hidden behind an interaction.</p>
<h2><a class="anchor" aria-hidden="true" id="updating-data"></a><a href="#updating-data" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Updating Data</h2>
<p>Relay holds a local in-memory store of normalized GraphQL data, which accumulates data as GraphQL queries are made throughout usage of our app; think of it as a local database of GraphQL data. When records are updated, any components affected by the updated data will be notified and re-rendered with the updated data.</p>
<p>In this section, we're going to go over how to update data in the server as well as how to update our local data store accordingly, ensuring that our components are kept in sync with the latest data.</p>
<h3><a class="anchor" aria-hidden="true" id="graphql-mutations"></a><a href="#graphql-mutations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>GraphQL Mutations</h3>
<p>In GraphQL, data in the server is updated using <a href="https://graphql.org/learn/queries/#mutations">GraphQL Mutations</a>. Mutations are <em>read-write</em> server operations, which both modify data in the backend, and allow querying for the modified data from the server in the same request.</p>
<p>A GraphQL mutation looks very similar to a query, with the exception that it uses the <strong><code>mutation</code></strong> keyword:</p>
<pre><code class="hljs css language-graphql">mutation <span class="hljs-constructor">LikePostMutation($<span class="hljs-params">input</span>: LikePostData!)</span> {
  like<span class="hljs-constructor">_post(<span class="hljs-params">data</span>: $<span class="hljs-params">input</span>)</span> {
    post {
      id
      viewer_does_like
      like_count
    }
  }
}
</code></pre>
<ul>
<li>The mutation above modifies the server data to &quot;like&quot; the specified <code>Post</code> object. The <strong><code>like_post</code></strong> field is the mutation field itself, which takes specific input and will be processed by the server to update the relevant data in the backend.</li>
<li><strong><code>like_post</code></strong> returns a specific GraphQL type which exposes the data we can query in the mutation response. In this case, we're querying for the <strong><em>updated</em></strong> post object, including the updated <code>like_count</code> and the updated value for <code>viewer_does_like</code>, indicating if the current viewer likes the post object.</li>
</ul>
<p>An example of a successful response for the above mutation could look like this:</p>
<pre><code class="hljs css language-json">{
  <span class="hljs-attr">"like_post"</span>: {
    <span class="hljs-attr">"post"</span>: {
      <span class="hljs-attr">"id"</span>: <span class="hljs-string">"post-id"</span>,
      <span class="hljs-attr">"viewer_does_like"</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">"like_count"</span>: <span class="hljs-number">1</span>,
    }
  }
}
</code></pre>
<p>In Relay, we can declare GraphQL mutations using the <code>graphql</code> tag too:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> {graphql} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay'</span>);

<span class="hljs-keyword">const</span> likeMutation = graphql<span class="hljs-string">`
  mutation LikePostMutation($input: LikePostData!) {
    like_post(data: $input) {
      post {
        id
        viewer_does_like
        like_count
      }
    }
  }
`</span>;
</code></pre>
<ul>
<li>Note that mutations can also reference GraphQL <a href="#variables">Variables</a> in the same way queries or fragments do.</li>
</ul>
<p>In order to <em>execute</em> a mutation against the server in Relay, we can use the <strong><code>commitMutation</code></strong> API:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {Environment} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-relay'</span>;
<span class="hljs-keyword">import</span> type {LikePostData, LikePostMutation} <span class="hljs-keyword">from</span> <span class="hljs-string">'LikePostMutation.graphql'</span>;

<span class="hljs-keyword">const</span> {commitMutation, graphql} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitLikePostMutation</span>(<span class="hljs-params">
  environment: Environment,
  input: LikePostData,
</span>) </span>{
  <span class="hljs-keyword">return</span> commitMutation&lt;LikePostMutation&gt;(environment, {
    <span class="hljs-attr">mutation</span>: graphql<span class="hljs-string">`
      mutation LikePostMutation($input: LikePostData!) {
        like_post(data: $input) {
          post {
            id
            viewer_does_like
            like_count
          }
        }
      }
    `</span>,
    <span class="hljs-attr">variables</span>: {input},
    <span class="hljs-attr">onCompleted</span>: <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {} <span class="hljs-comment">/* Mutation completed */</span>,
    <span class="hljs-attr">onError</span>: <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {} <span class="hljs-comment">/* Mutation errored */</span>,
  });
}

<span class="hljs-built_in">module</span>.exports = {<span class="hljs-attr">commit</span>: commitLikePostMutation};
</code></pre>
<p>Let's distill what's happening here:</p>
<ul>
<li><code>commitMutation</code> takes an environment, the <code>graphql</code> tagged  mutation, and the variables to use for sending the mutation request to the server.</li>
<li>Note that the <code>input</code> for the mutation can be Flow typed with the autogenerated type available from the <em><code>LikePostMutation.graphql</code></em> module. In general, the Relay will generate Flow types for mutations at build time, with the following naming format: <code>&lt;mutation_name&gt;.graphql.js</code>.</li>
<li>Note that the <code>variables</code>, <code>response</code> in <code>onComplete</code> and <code>optimisticResponse</code> in <code>commitMutation</code> will be typed altogether by providing the autogenerated type <code>LikePostMutation</code> from the <em><code>LikePostMutation.graphql</code></em> module. To include the type for the <code>optimisticResponse</code>, a <code>@raw_response_type</code> directive should be added to the mutation query root.</li>
<li><code>commitMutation</code> also takes an <code>onCompleted</code> and <code>onError</code> callbacks, which will respectively be called when the request completes successfully or when an error occurs.</li>
<li>When the mutation response is received, <strong><em>if the objects in the mutation response have IDs, the records in the local store will <em>automatically</em> be updated with the new field values from the response.</em></strong> In this case, it would automatically find the existing <code>Post</code> object matching the given ID in the store, and update the values for its <code>viewer_does_like</code> and <code>like_count</code> fields.</li>
<li>Note that any local data updates caused by the mutation will automatically cause components subscribed to the data to be notified of the change and re-render.</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="updater-functions"></a><a href="#updater-functions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Updater Functions</h4>
<p>However, if the updates you wish to perform on the local data in response to the mutation are more complex than just updating the values of fields, like deleting or creating new records, or <a href="#adding-and-removing-items-from-a-connection">Adding and Removing Items From a Connection</a>, you can provide an <strong><code>updater</code></strong> function to <code>commitMutation</code> for full control over how to update the store:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {Environment} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-relay'</span>;
<span class="hljs-keyword">import</span> type {CommentCreateData, CreateCommentMutation} <span class="hljs-keyword">from</span> <span class="hljs-string">'CreateCommentMutation.graphql'</span>;

<span class="hljs-keyword">const</span> {commitMutation, graphql} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitCommentCreateMutation</span>(<span class="hljs-params">
  environment: Environment,
  postID: string,
  input: CommentCreateData,
</span>) </span>{
  <span class="hljs-keyword">return</span> commitMutation&lt;CreateCommentMutation&gt;(environment, {
    <span class="hljs-attr">mutation</span>: graphql<span class="hljs-string">`
      mutation CreateCommentMutation($input: CommentCreateData!) {
        comment_create(input: $input) {
          comment_edge {
            cursor
            node {
              body {
                text
              }
            }
          }
        }
      }
    `</span>,
    <span class="hljs-attr">variables</span>: {input},
    <span class="hljs-attr">onCompleted</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {},
    <span class="hljs-attr">onError</span>: <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {},
    <span class="hljs-attr">updater</span>: <span class="hljs-function"><span class="hljs-params">store</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> postRecord = store.get(postID);

      <span class="hljs-comment">// Get connection record</span>
      <span class="hljs-keyword">const</span> connectionRecord = ConnectionHandler.getConnection(
        postRecord,
        <span class="hljs-string">'CommentsComponent_comments_connection'</span>,
      );

      <span class="hljs-comment">// Get the payload returned from the server</span>
      <span class="hljs-keyword">const</span> payload = store.getRootField(<span class="hljs-string">'comment_create'</span>);

      <span class="hljs-comment">// Get the edge inside the payload</span>
      <span class="hljs-keyword">const</span> serverEdge = payload.getLinkedRecord(<span class="hljs-string">'comment_edge'</span>);

      <span class="hljs-comment">// Build edge for adding to the connection</span>
      <span class="hljs-keyword">const</span> newEdge = ConnectionHandler.buildConnectionEdge(
        store,
        connectionRecord,
        serverEdge,
      );

      <span class="hljs-comment">// Add edge to the end of the connection</span>
      ConnectionHandler.insertEdgeAfter(
        connectionRecord,
        newEdge,
      );
    },
  });
}

<span class="hljs-built_in">module</span>.exports = {<span class="hljs-attr">commit</span>: commitCommentCreateMutation};
</code></pre>
<p>Let's distill this example:</p>
<ul>
<li><code>updater</code> takes a <em><code>store</code></em> argument, which is an instance of a <code>[RecordSourceSelectorProxy](https://relay.dev/docs/en/relay-store.html#recordsourceselectorproxy)</code>;  this interface allows you to <em>imperatively</em> write and read data directly to and from the Relay store. This means that you have full control over how to update the store in response to the mutation response: you can <em>create entirely new records</em>, or <em>update or delete existing ones</em>. The full API for reading and writing to the Relay store is available here: <a href="https://relay.dev/docs/en/relay-store.html">https://relay.dev/docs/en/relay-store.html</a></li>
<li>In our specific example, we're adding a new comment to our local store after it has successfully been added on the server. Specifically, we're adding a new item to a connection; for more details on the specifics of how that works, check out our <a href="#adding-and-removing-items-from-a-connection">Adding and Removing Items From a Connection</a> section.</li>
<li>Note that the mutation response is a <em>root field</em> record that can be read from the <code>store</code>, specifically using the <code>store.getRootField</code> API. In our case, we're reading the <code>comment_create</code> root field, which is a root field in the mutation response.</li>
<li>Note that any local data updates caused by the mutation <code>updater</code> will automatically cause components subscribed to the data to be notified of the change and re-render.</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="optimistic-updates"></a><a href="#optimistic-updates" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optimistic updates</h4>
<p>Often times when executing a mutation we don't want to wait for the server response to complete before we respond to user interaction. For example, if a user clicks the &quot;Like&quot; button, we don't want to wait until the mutation response comes back before we show them that the post has been liked; ideally, we'd do that instantly.</p>
<p>More generally, in these cases we want to immediately update our local data <em>optimistically</em>, in order to improve perceived responsiveness; that is, we want to update our local data to immediately reflect what it would look like after the mutation <em>succeeds</em>. If the mutation ends up <em>not</em> succeeding, we can roll back the change and show an error message, but we're <em>optimistically</em> expecting the mutation to succeed most of the time.</p>
<p>In order to do this, Relay provides 2 APIs to specify an optimistic update when executing a mutation:</p>
<p><em><strong>Optimistic Response</strong></em></p>
<p>When you can predict what the server response for a mutation is going to be, the simplest way to optimistically update the store is by providing an <strong><code>optimisticResponse</code></strong> to <code>commitMutation</code>:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {Environment} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-relay'</span>;
<span class="hljs-keyword">import</span> type {LikePostData, LikePostMutation} <span class="hljs-keyword">from</span> <span class="hljs-string">'LikePostMutation.graphql'</span>;

<span class="hljs-keyword">const</span> {commitMutation, graphql} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitLikePostMutation</span>(<span class="hljs-params">
  environment: Environment,
  postID: string,
  input: LikePostData,
</span>) </span>{
  <span class="hljs-keyword">return</span> commitMutation&lt;LikePostMutation&gt;(environment, {
    <span class="hljs-attr">mutation</span>: graphql<span class="hljs-string">`
      mutation LikePostMutation($input: LikePostData!)
        @raw_response_type {
        like_post(data: $input) {
          post {
            id
            viewer_does_like
          }
        }
      }
    `</span>,
    <span class="hljs-attr">variables</span>: {input},
    <span class="hljs-attr">optimisticResponse</span>: {
      <span class="hljs-attr">like_post</span>: {
        <span class="hljs-attr">post</span>: {
          <span class="hljs-attr">id</span>: postID,
          <span class="hljs-attr">viewer_does_like</span>: <span class="hljs-literal">true</span>,
        },
      },
    },
    <span class="hljs-attr">onCompleted</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {} <span class="hljs-comment">/* Mutation completed */</span>,
    <span class="hljs-attr">onError</span>: <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {} <span class="hljs-comment">/* Mutation errored */</span>,
  });
}

<span class="hljs-built_in">module</span>.exports = {<span class="hljs-attr">commit</span>: commitLikePostMutation};
</code></pre>
<p>Let's see what's happening in this example.</p>
<ul>
<li>The <code>optimisticResponse</code> is an object matching the shape of the mutation response, and it simulates a successful response from the server. When <code>optimisticResponse</code>, is provided, Relay will automatically process the response in the same way it would process the response from the server, and update the data accordingly (i.e. update the values of fields for the record with the matching id).
<ul>
<li>In this case, we would immediately set the <code>viewer_does_like</code> field to <code>true</code> in our <code>Post</code> object, which would be immediately reflected in our UI.</li>
</ul></li>
<li>If the mutation <em>succeeds</em>, <strong><em>the optimistic update will be rolled back,</em></strong> and the server response will be applied.</li>
<li>If the mutation <em>fails</em>, <strong><em>the optimistic update will be rolled back,</em></strong> and the error will be communicated via the <code>onError</code> callback.</li>
<li>Note that by adding <code>@raw_response_type</code> directive,  the type for <code>optimisticResponse</code> is generated , and the flow type is applied by: <code>commitMutation&lt;LikePostMutation&gt;</code>.</li>
</ul>
<p><em><strong>Optimistic Updater</strong></em></p>
<p>However, in some cases we can't statically predict what the server response will be, or we need to optimistically perform more complex updates, like deleting or creating new records, or <a href="#adding-and-removing-items-from-a-connection">Adding and Removing Items From a Connection</a>. In these cases we can provide an <strong><code>optimisticUpdater</code></strong> function to <code>commitMutation</code>. For example, we can rewrite the above example using an <code>optimisticUpdater</code> instead of an <code>optimisticResponse</code>:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {Environment} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-relay'</span>;
<span class="hljs-keyword">import</span> type {LikePostData} <span class="hljs-keyword">from</span> <span class="hljs-string">'LikePostMutation.graphql'</span>;

<span class="hljs-keyword">const</span> {commitMutation, graphql} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitLikePostMutation</span>(<span class="hljs-params">
  environment: Environment,
  postID: string,
  input: LikePostData,
</span>) </span>{
  <span class="hljs-keyword">return</span> commitMutation(environment, {
    <span class="hljs-attr">mutation</span>: graphql<span class="hljs-string">`
      mutation LikePostMutation($input: LikePostData!) {
        like_post(data: $input) {
          post {
            id
            like_count
            viewer_does_like
          }
        }
      }
    `</span>,
    <span class="hljs-attr">variables</span>: {input},
    <span class="hljs-attr">optimisticUpdater</span>: <span class="hljs-function"><span class="hljs-params">store</span> =&gt;</span> {
      <span class="hljs-comment">// Get the record for the Post object</span>
      <span class="hljs-keyword">const</span> postRecord = store.get(postID);

      <span class="hljs-comment">// Read the current value for the like_count</span>
      <span class="hljs-keyword">const</span> currentLikeCount = postRecord.getValue(<span class="hljs-string">'like_count'</span>);

      <span class="hljs-comment">// Optimistically increment the like_count by 1</span>
      postRecord.setValue((currentLikeCount ?? <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>, <span class="hljs-string">'like_count'</span>);

      <span class="hljs-comment">// Optimistically set viewer_does_like to true</span>
      postRecord.setValue(<span class="hljs-literal">true</span>, <span class="hljs-string">'viewer_does_like'</span>);
    },
    <span class="hljs-attr">onCompleted</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {} <span class="hljs-comment">/* Mutation completed */</span>,
    <span class="hljs-attr">onError</span>: <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {} <span class="hljs-comment">/* Mutation errored */</span>,
  });
}

<span class="hljs-built_in">module</span>.exports = {<span class="hljs-attr">commit</span>: commitLikePostMutation};
</code></pre>
<p>Let's see what's happening here:</p>
<ul>
<li>The <code>optimisticUpdater</code> has the same signature and behaves the same way as the regular <code>updater</code> function, the main difference being that it will be executed immediately, before the mutation response completes.</li>
<li>If the mutation succeeds, <strong><em>the optimistic update will be rolled back,</em></strong> and the server response will be applied.
<ul>
<li>Note that if we used an <code>optimisticResponse</code>, we wouldn't able to statically provide a value for <code>like_count</code>, since it requires reading the current value from the store first, which we can do with an <code>optimisticUpdater</code>.</li>
<li>Also note that when mutation completes, the value from the server might differ from the value we optimistically predicted locally. For example, if other &quot;Likes&quot; occurred at the same time, the final <code>like_count</code> from the server might've incremented by more than 1.</li>
</ul></li>
<li>If the mutation <em>fails</em>, <strong><em>the optimistic update will be rolled back,</em></strong> and the error will be communicated via the <code>onError</code> callback.</li>
<li>Note that we're not providing an <code>updater</code> function, which is okay. If it's not provided, the default behavior will still be applied when the server response arrives (i.e. merging the new field values for <code>like_count</code> and <code>viewer_does_like</code> on the <code>Post</code> object).</li>
</ul>
<blockquote>
<p><strong>NOTE:</strong> Remember that any updates to local data caused by a mutation will automatically notify and re-render components subscribed to that data.</p>
</blockquote>
<h4><a class="anchor" aria-hidden="true" id="order-of-execution-of-updater-functions"></a><a href="#order-of-execution-of-updater-functions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Order of Execution of Updater Functions</h4>
<p>In general, execution of the <code>updater</code> and optimistic updates will occur in the following order:</p>
<ul>
<li>If an <code>optimisticResponse</code> is provided, Relay will use it to merge the new field values for the records that match the ids in the <code>optimisticResponse</code>.</li>
<li>If <code>optimisticUpdater</code> is provided, Relay will execute it and update the store accordingly.</li>
<li>If the mutation request succeeds:
<ul>
<li>Any optimistic update that was applied will be rolled back.</li>
<li>Relay will use the server response to merge the new field values for the records that match the ids in the response.</li>
<li>If an <code>updater</code> was provided, Relay will execute it and update the store accordingly. The server payload will be available to the <code>updater</code> as a root field in the store.</li>
</ul></li>
<li>If the mutation request fails:
<ul>
<li>Any optimistic update was applied will be rolled back.</li>
<li>The <code>onError</code> callback will be called.</li>
</ul></li>
</ul>
<p><em><strong>Full Example</strong></em></p>
<p>This means that in more complicated scenarios you can still provide all 3 options: <code>optimisticResponse</code>, <code>optimisticUpdater</code> and <code>updater</code>. For example, the mutation to add a new comment could like something like the following (for full details on updating connections, check out our <a href="#adding-and-removing-items-from-a-connection">Adding and Removing Items From a Connection</a> guide):</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {Environment} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-relay'</span>;
<span class="hljs-keyword">import</span> type {CommentCreateData, CreateCommentMutation} <span class="hljs-keyword">from</span> <span class="hljs-string">'CreateCommentMutation.graphql'</span>;

<span class="hljs-keyword">const</span> {commitMutation, graphql} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitCommentCreateMutation</span>(<span class="hljs-params">
  environment: Environment,
  postID: string,
  input: CommentCreateData,
</span>) </span>{
  <span class="hljs-keyword">return</span> commitMutation&lt;CreateCommentMutation&gt;(environment, {
    <span class="hljs-attr">mutation</span>: graphql<span class="hljs-string">`
      mutation CreateCommentMutation($input: CommentCreateData!) {
        comment_create(input: $input) {
          post {
            id
            viewer_has_commented
          }
          comment_edge {
            cursor
            node {
              body {
                text
              }
            }
          }
        }
      }
    `</span>,
    <span class="hljs-attr">variables</span>: {input},
    <span class="hljs-attr">onCompleted</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {},
    <span class="hljs-attr">onError</span>: <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {},

    <span class="hljs-comment">// Optimistically set the value for `viewer_has_commented`</span>
    <span class="hljs-attr">optimisticResponse</span>: {
      <span class="hljs-attr">post</span>: {
        <span class="hljs-attr">id</span>: postID,
        <span class="hljs-attr">viewer_has_commented</span>: <span class="hljs-literal">true</span>,
      },
    },

    <span class="hljs-comment">// Optimistically add a new comment to the comments connection</span>
    <span class="hljs-attr">optimisticUpdater</span>: <span class="hljs-function"><span class="hljs-params">store</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> postRecord = store.get(postID);
      <span class="hljs-keyword">const</span> connectionRecord = ConnectionHandler.getConnection(
        userRecord,
        <span class="hljs-string">'CommentsComponent_comments_connection'</span>,
      );

      <span class="hljs-comment">// Create a new local Comment from scratch</span>
      <span class="hljs-keyword">const</span> id = <span class="hljs-string">`client:new_comment:<span class="hljs-subst">${randomID()}</span>`</span>;
      <span class="hljs-keyword">const</span> newCommentRecord = store.create(id, <span class="hljs-string">'Comment'</span>);

      <span class="hljs-comment">// ... update new comment with content</span>

      <span class="hljs-comment">// Create new edge from scratch</span>
      <span class="hljs-keyword">const</span> newEdge = ConnectionHandler.createEdge(
        store,
        connectionRecord,
        newCommentRecord,
        <span class="hljs-string">'CommentEdge'</span> <span class="hljs-comment">/* GraphQl Type for edge */</span>,
      );

      <span class="hljs-comment">// Add edge to the end of the connection</span>
      ConnectionHandler.insertEdgeAfter(connectionRecord, newEdge);
    },
    <span class="hljs-attr">updater</span>: <span class="hljs-function"><span class="hljs-params">store</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> postRecord = store.get(postID);
      <span class="hljs-keyword">const</span> connectionRecord = ConnectionHandler.getConnection(
        userRecord,
        <span class="hljs-string">'CommentsComponent_comments_connection'</span>,
      );

      <span class="hljs-comment">// Get the payload returned from the server</span>
      <span class="hljs-keyword">const</span> payload = store.getRootField(<span class="hljs-string">'comment_create'</span>);

      <span class="hljs-comment">// Get the edge from server payload</span>
      <span class="hljs-keyword">const</span> newEdge = payload.getLinkedRecord(<span class="hljs-string">'comment_edge'</span>);

      <span class="hljs-comment">// Add edge to the end of the connection</span>
      ConnectionHandler.insertEdgeAfter(connectionRecord, newEdge);
    },
  });
}

<span class="hljs-built_in">module</span>.exports = {<span class="hljs-attr">commit</span>: commitCommentCreateMutation};
</code></pre>
<p>Let's distill this example, according to the execution order of the updaters:</p>
<ul>
<li>Given that an <code>optimisticResponse</code> was provided, it will be executed <em>first</em>. This will cause the new value of <code>viewer_has_commented</code> to be merged into the existing <code>Post</code> object, setting it to <code>true</code>.</li>
<li>Given that an <code>optimisticResponse</code> was provided, it will be executed next. Our <code>optimisticUpdater</code> will create new comment and edge records from scratch, simulating what the new edge in the server response would look like, and then add the new edge to the connection.</li>
<li>When the optimistic updates conclude, components subscribed to this data will be notified.</li>
<li>When the mutation succeeds, all of our optimistic updates will be rolled back.</li>
<li>The server response will be processed by Relay, and this will cause the new value of <code>viewer_has_commented</code> to be merged into the existing <code>Post</code> object, setting it to <code>true</code>.</li>
<li>Finally, the <code>updater</code> function we provided will be executed. The <code>updater</code> function is very similar to the <code>optimisticUpdater</code> function, however, instead of creating the new data from scratch, it reads it from the mutation payload and adds the new edge to the connection.</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="invalidating-data-during-a-mutation"></a><a href="#invalidating-data-during-a-mutation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Invalidating Data during a Mutation</h4>
<p>The recommended approach when executing a mutation is to request <strong><em>all</em></strong> the relevant data that was affected by the mutation back from the server (as part of the mutation body), so that our local Relay store is consistent with the state of the server.</p>
<p>However, often times it can be unfeasible to know and specify all the possible data the possible data that would be affected for mutations that have large rippling effects (e.g. imagine ‚Äúblocking a user‚Äù or ‚Äúleaving a group‚Äù).</p>
<p>For these types of mutations, it‚Äôs often more straightforward to explicitly mark some data as stale (or the whole store), so that Relay knows to refetch it the next time it is rendered. In order to do so, you can use the data invalidation apis documented in our <a href="#staleness-of-data">Staleness of Data section</a>.</p>
<h4><a class="anchor" aria-hidden="true" id="mutation-queueing"></a><a href="#mutation-queueing" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mutation Queueing</h4>
<blockquote>
<p><strong>TODO:</strong> Left to be implemented in user space</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="graphql-subscriptions"></a><a href="#graphql-subscriptions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>GraphQL Subscriptions</h3>
<p><a href="https://graphql.org/blog/subscriptions-in-graphql-and-relay/">GraphQL Subscriptions</a> (GQLS) are a mechanism which allows clients to subscribe to changes in a piece of data from the server, and get notified whenever that data changes.</p>
<p>A GraphQL Subscription looks very similar to a query, with the exception that it uses the subscription keyword:</p>
<pre><code class="hljs css language-graphql">subscription <span class="hljs-constructor">LikePostSubscription($<span class="hljs-params">input</span>: LikePostSubscribeData!)</span> {
  like<span class="hljs-constructor">_post_subscribe(<span class="hljs-params">data</span>: $<span class="hljs-params">input</span>)</span> {
    post {
      id
      like_count
    }
  }
}
</code></pre>
<ul>
<li>Subscribing to the above subscription will notify the client whenever the specified <code>Post</code> object has been &quot;liked&quot; or &quot;unliked&quot;. The <strong><code>like_post_subscribe</code></strong> field is the subscription field itself, which takes specific input and will set up the subscription in the backend.</li>
<li><strong><code>like_post_subscribe</code></strong> returns a specific GraphQL type which exposes the data we can query in the subscription payload; that is, whenever the client is notified, it will receive the subscription payload in the notification. In this case, we're querying for the Post object with it's <strong><em>updated</em></strong> <code>like_count</code>, which will allows us to show the like count in real time.</li>
</ul>
<p>An example of a subscription payload received by the client could look like this:</p>
<pre><code class="hljs css language-javascript">{
  <span class="hljs-string">"like_post_subscribe"</span>: {
    <span class="hljs-string">"post"</span>: {
      <span class="hljs-string">"id"</span>: <span class="hljs-string">"post-id"</span>,
      <span class="hljs-string">"like_count"</span>: <span class="hljs-number">321</span>,
    }
  }
}
</code></pre>
<p>In Relay, we can declare GraphQL subcriptions using the <code>graphql</code> tag too:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> {graphql} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay'</span>);

<span class="hljs-keyword">const</span> postLikeSubscription = graphql<span class="hljs-string">`
  subscription LikePostSubscription($input: LikePostSubscribeData!) {
    like_post_subscribe(data: $input) {
      post {
        id
        like_count
      }
    }
  }
`</span>;
</code></pre>
<ul>
<li>Note that subscriptions can also reference GraphQL <a href="#variables">Variables</a> in the same way queries or fragments do.</li>
</ul>
<p>In order to <em>execute</em> a subscription against the server in Relay, we can use the <strong><code>requestSubscription</code></strong> API:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {Environment} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-relay'</span>;
<span class="hljs-keyword">import</span> type {LikePostSubscribeData} <span class="hljs-keyword">from</span> <span class="hljs-string">'LikePostSubscription.graphql'</span>;

<span class="hljs-keyword">const</span> {graphql, requestSubscription} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postLikeSubscribe</span>(<span class="hljs-params">
  environment: Environment,
  postID: string,
  input: LikePostSubscribeData,
</span>) </span>{
  <span class="hljs-keyword">return</span> requestSubscription(environment, {
    <span class="hljs-attr">subscription</span>: graphql<span class="hljs-string">`
      subscription LikePostSubscription(
        $input: LikePostSubscribeData!
      ) {
        like_post_subscribe(data: $input) {
          post {
            id
            like_count
          }
        }
      }
    `</span>,
    <span class="hljs-attr">variables</span>: {input},
    <span class="hljs-attr">onCompleted</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {} <span class="hljs-comment">/* Subscription established */</span>,
    <span class="hljs-attr">onError</span>: <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {} <span class="hljs-comment">/* Subscription errored */</span>,
    <span class="hljs-attr">onNext</span>: <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {} <span class="hljs-comment">/* Subscription payload received */</span>
  });
}

<span class="hljs-built_in">module</span>.exports = {<span class="hljs-attr">subscribe</span>: postLikeSubscribe};
</code></pre>
<p>Let's distill what's happening here:</p>
<ul>
<li><code>requestSubscription</code> takes an environment, the <code>graphql</code> tagged subscription, and the variables to use.</li>
<li>Note that the <code>input</code> for the subscription can be Flow typed with the autogenerated type available from the <em><code>LikePostSubscription.graphql</code></em> module. In general, the Relay will generate Flow types for subscriptions at build time, with the following naming format: <code>&lt;subscription_name&gt;.graphql.js</code>.</li>
<li><code>requestSubscription</code> also takes an <code>onCompleted</code> and <code>onError</code> callbacks, which will respectively be called when the subscription is successfully established, or when an error occurs.</li>
<li><code>requestSubscription</code> also takes an <code>onNext</code> callback, which will be called whenever a subscription payload is received.</li>
<li>When the subscription payload is received, <strong><em>if the objects in the subscription payload have IDs, the records in the local store will <em>automatically</em> be updated with the new field values from the payload.</em></strong> In this case, it would automatically find the existing <code>Post</code> object matching the given ID in the store, and update the values for the <code>like_count</code> field.</li>
<li>Note that any local data updates caused by the subscription will automatically cause components subscribed to the data to be notified of the change and re-render.</li>
</ul>
<p>However, if the updates you wish to perform on the local data in response to the subscription are more complex than just updating the values of fields, like deleting or creating new records, or <a href="#adding-and-removing-items-from-a-connection">Adding and Removing Items From a Connection</a>, you can provide an <code>**updater**</code> function to <strong><code>requestSubscription</code></strong> for full control over how to update the store:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {Environment} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-relay'</span>;
<span class="hljs-keyword">import</span> type {CommentCreateSubscribeData} <span class="hljs-keyword">from</span> <span class="hljs-string">'CommentCreateSubscription.graphql'</span>;

<span class="hljs-keyword">const</span> {graphql, requestSubscription} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commentCreateSubscribe</span>(<span class="hljs-params">
  environment: Environment,
  postID: string,
  input: CommentCreateSubscribeData,
</span>) </span>{
  <span class="hljs-keyword">return</span> requestSubscription(environment, {
    <span class="hljs-attr">subscription</span>: graphql<span class="hljs-string">`
      subscription CommentCreateSubscription(
        $input: CommentCreateSubscribeData!
      ) {
        comment_create_subscribe(data: $input) {
          post_comment_edge {
            cursor
            node {
              body {
                text
              }
            }
          }
        }
      }
    `</span>,
    <span class="hljs-attr">variables</span>: {input},
    <span class="hljs-attr">updater</span>: <span class="hljs-function"><span class="hljs-params">store</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> postRecord = store.get(postID);

      <span class="hljs-comment">// Get connection record</span>
      <span class="hljs-keyword">const</span> connectionRecord = ConnectionHandler.getConnection(
        postRecord,
        <span class="hljs-string">'CommentsComponent_comments_connection'</span>,
      );

      <span class="hljs-comment">// Get the payload returned from the server</span>
      <span class="hljs-keyword">const</span> payload = store.getRootField(<span class="hljs-string">'comment_create_subscribe'</span>);

      <span class="hljs-comment">// Get the edge inside the payload</span>
      <span class="hljs-keyword">const</span> serverEdge = payload.getLinkedRecord(<span class="hljs-string">'post_comment_edge'</span>);

      <span class="hljs-comment">// Build edge for adding to the connection</span>
      <span class="hljs-keyword">const</span> newEdge = ConnectionHandler.buildConnectionEdge(
        store,
        connectionRecord,
        serverEdge,
      );

      <span class="hljs-comment">// Add edge to the end of the connection</span>
      ConnectionHandler.insertEdgeAfter(connectionRecord, newEdge);
    },
    <span class="hljs-attr">onCompleted</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {} <span class="hljs-comment">/* Subscription established */</span>,
    <span class="hljs-attr">onError</span>: <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {} <span class="hljs-comment">/* Subscription errored */</span>,
    <span class="hljs-attr">onNext</span>: <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {} <span class="hljs-comment">/* Subscription payload received */</span>,
  });
}

<span class="hljs-built_in">module</span>.exports = {<span class="hljs-attr">subscribe</span>: commentCreateSubscribe};
</code></pre>
<p>Let's distill this example:</p>
<ul>
<li><code>updater</code> takes a <em><code>store</code></em> argument, which is an instance of a <code>[RecordSourceSelectorProxy](https://relay.dev/docs/en/relay-store.html#recordsourceselectorproxy)</code>;  this interface allows you to <em>imperatively</em> write and read data directly to and from the Relay store. This means that you have full control over how to update the store in response to the subscription payload: you can <em>create entirely new records</em>, or <em>update or delete existing ones</em>. The full API for reading and writing to the Relay store is available here: <a href="https://relay.dev/docs/en/relay-store.html">https://relay.dev/docs/en/relay-store.html</a></li>
<li>In our specific example, we're adding a new comment to our local store when we receive a subscription payload notifying us that a new comment has been created. Specifically, we're adding a new item to a connection; for more details on the specifics of how that works, check out our <a href="#adding-and-removing-items-from-a-connection">Adding and Removing Items From a Connection</a> section.</li>
<li>Note that the subscription payload is a <em>root field</em> record that can be read from the <code>store</code>, specifically using the <code>store.getRootField</code> API. In our case, we're reading the <code>comment_create_subcribe</code> root field, which is a root field in the subscription response.</li>
<li>Note that any local data updates caused by the mutation <code>updater</code> will automatically cause components subscribed to the data to be notified of the change and re-render.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="local-data-updates"></a><a href="#local-data-updates" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Local Data Updates</h3>
<p>There are a couple of APIs that Relay provides in order to make purely local updates to the Relay store (i.e. updates not tied to a server operation).</p>
<p>Note that local data updates can be made both on <a href="#client-only-data-client-schema-extensions">client-only data</a>, or on regular data that was fetched from the server via an operation.</p>
<h4><a class="anchor" aria-hidden="true" id="commitlocalupdate"></a><a href="#commitlocalupdate" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>commitLocalUpdate</h4>
<p>To make updates using an <code>updater</code> function, you can use the <strong><code>commitLocalUpdate</code></strong> API:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {Environment} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-relay'</span>;

<span class="hljs-keyword">const</span> {commitLocalUpdate, graphql} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitCommentCreateLocally</span>(<span class="hljs-params">
  environment: Environment,
  postID: string,
</span>) </span>{
  <span class="hljs-keyword">return</span> commitLocalUpdate(environment, store =&gt; {
    <span class="hljs-keyword">const</span> postRecord = store.get(postID);
    <span class="hljs-keyword">const</span> connectionRecord = ConnectionHandler.getConnection(
      userRecord,
      <span class="hljs-string">'CommentsComponent_comments_connection'</span>,
    );

    <span class="hljs-comment">// Create a new local Comment from scratch</span>
    <span class="hljs-keyword">const</span> id = <span class="hljs-string">`client:new_comment:<span class="hljs-subst">${randomID()}</span>`</span>;
    <span class="hljs-keyword">const</span> newCommentRecord = store.create(id, <span class="hljs-string">'Comment'</span>);

    <span class="hljs-comment">// ... update new comment with content</span>

    <span class="hljs-comment">// Create new edge from scratch</span>
    <span class="hljs-keyword">const</span> newEdge = ConnectionHandler.createEdge(
      store,
      connectionRecord,
      newCommentRecord,
      <span class="hljs-string">'CommentEdge'</span> <span class="hljs-comment">/* GraphQl Type for edge */</span>,
    );

    <span class="hljs-comment">// Add edge to the end of the connection</span>
    ConnectionHandler.insertEdgeAfter(connectionRecord, newEdge);
  });
}

<span class="hljs-built_in">module</span>.exports = {<span class="hljs-attr">commit</span>: commitCommentCreateLocally};
</code></pre>
<ul>
<li><code>commitLocalUpdate</code> update simply takes an environment and an updater function.
<ul>
<li><code>updater</code> takes a <em><code>store</code></em> argument, which is an instance of a <code>[RecordSourceSelectorProxy](https://relay.dev/docs/en/relay-store.html#recordsourceselectorproxy)</code>;  this interface allows you to <em>imperatively</em> write and read data directly to and from the Relay store. This means that you have full control over how to update the store: you can <em>create entirely new records</em>, or <em>update or delete existing ones</em>. The full API for reading and writing to the Relay store is available here: <a href="https://relay.dev/docs/en/relay-store.html">https://relay.dev/docs/en/relay-store.html</a></li>
</ul></li>
<li>In our specific example, we're adding a new comment to our local store when. Specifically, we're adding a new item to a connection; for more details on the specifics of how that works, check out our <a href="#adding-and-removing-items-from-a-connection">Adding and Removing Items From a Connection</a> section.</li>
<li>Note that any local data updates will automatically cause components subscribed to the data to be notified of the change and re-render.</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="commitpayload"></a><a href="#commitpayload" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CommitPayload</h4>
<p><strong><code>commitPayload</code></strong> takes an <code>OperationDescriptor</code> and the payload for the query, and writes it to the Relay Store. The payload will be resolved like a normal server response for a query.</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {FooQueryRawResponse} <span class="hljs-keyword">from</span> <span class="hljs-string">'FooQuery.graphql'</span>

<span class="hljs-keyword">const</span> {createOperationDescriptor} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'relay-runtime'</span>);

<span class="hljs-keyword">const</span> operationDescriptor = createOperationDescriptor(FooQuery, {
  <span class="hljs-attr">id</span>: <span class="hljs-string">'an-id'</span>,
  <span class="hljs-attr">otherVariable</span>: <span class="hljs-string">'value'</span>,
});

<span class="hljs-keyword">const</span> payload: FooQueryRawResponse = {...};

environment.commitPayload(operation, payload);
</code></pre>
<ul>
<li>An <code>OperationDescriptor</code> can be created by using <code>createOperationDescriptor</code>; it takes the query and the query variables.</li>
<li>The payload can be typed using the Flow type generated by adding  @raw_response_type to the query.</li>
<li>Note that any local data updates will automatically cause components subscribed to the data to be notified of the change and re-render.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="client-only-data-client-schema-extensions"></a><a href="#client-only-data-client-schema-extensions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Client-Only Data (Client Schema Extensions)</h3>
<p>Relay provides the ability to extend the GraphQL schema <strong><em>on the client</em></strong> (i.e. in the browser), via client schema extensions, in order to model data that only needs to be created, read and updated on the client. This can be useful to add small pieces of information to data that is fetched from the server, or to entirely model client-specific state to be stored and managed by Relay.</p>
<p>Client schema extensions allows you to modify existing types on the schema (e.g. by adding new fields to a type), or to create entirely new types that only exist in the client.</p>
<h4><a class="anchor" aria-hidden="true" id="adding-a-client-schema-file"></a><a href="#adding-a-client-schema-file" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Adding a Client Schema file</h4>
<p>To add a client schema, create a new <code>.graphql</code> file inside your src directory. The file can be named anything.</p>
<h4><a class="anchor" aria-hidden="true" id="extending-existing-types"></a><a href="#extending-existing-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Extending Existing Types</h4>
<p>In order to extend an existing type, add a <code>.graphql</code> file to the appropriate schema extension file:</p>
<pre><code class="hljs css language-graphql">extend<span class="hljs-built_in"> type </span>Comment {
  is_new_comment: Boolean
}
</code></pre>
<ul>
<li>In this example, we're using the <strong><code>extend</code></strong> keyword to extend an existing type, and we're adding a new field, <code>is_new_comment</code> to the existing <code>Comment</code> type, which we will be able to <a href="#reading-client-only-data">read</a> in our components, and <a href="#updating-client-only-data">update</a> when necessary using normal Relay APIs; you might imagine that we might use this field to render a different visual treatment for a comment if it's new, and we might set it when creating a new comment.</li>
<li>Note that in order for Relay to pick up this extension, the file needs to be inside your src directory. The file can be named anything, e.g.: <code>clientSchema.graphql</code>.</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="adding-new-types"></a><a href="#adding-new-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Adding New Types</h4>
<p>You can define types using the same regular GraphQL syntax, by defining it inside your client schema file:</p>
<pre><code class="hljs css language-graphql">enum FetchStatus {
  FETCHED
  PENDING
  ERRORED
}
<span class="hljs-built_in">
type </span>FetchState {
  # You can reuse client-only types <span class="hljs-keyword">to</span> define other types
  status: FetchStatus

  # You can also reference regular<span class="hljs-built_in"> server </span>types
  started_by: User!
}

extend<span class="hljs-built_in"> type </span>Item {
  # You can extend<span class="hljs-built_in"> server </span>types with client-only types
  fetch_state: FetchState
}
</code></pre>
<ul>
<li>In this contrived example, we're defining 2 new client-only types, and <code>enum</code> and a regular <code>type</code>. Note that they can reference themselves as normal, and reference regular server defined types. Also note that we can extend server types and add fields that are of our client-only types.</li>
<li>As mentioned previously, we will be able  <a href="#reading-client-only-data">read</a> and <a href="#updating-client-only-data">update</a> this data normally via Relay APIs.</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="reading-client-only-data"></a><a href="#reading-client-only-data" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reading Client-Only Data</h4>
<p>We can read client-only data be selecting it inside<a href="#fragments">fragments</a> or <a href="#queries">queries</a> as normal:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> data = *useFragment*(
  graphql<span class="hljs-string">`
    fragment CommentComponent_comment on Comment {

      # We can select client-only fields as we would any other field
      is_new_comment

      body {
        text
      }
    }
  `</span>,
  props.user,
);
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="updating-client-only-data"></a><a href="#updating-client-only-data" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Updating Client-Only Data</h4>
<p>In order to update client-only data, you can do so regularly inside <a href="#graphql-mutations">mutation</a> or <a href="#graphql-subscriptions">subscription</a> updaters, or by using our primitives for doing <a href="#local-data-updates">local updates</a> to the store.</p>
<h2><a class="anchor" aria-hidden="true" id="local-application-state-management"></a><a href="#local-application-state-management" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Local Application State Management</h2>
<blockquote>
<p><strong>TODO</strong></p>
</blockquote>
<p>Roughly, at a high level:</p>
<ol>
<li>Read data from Relay</li>
<li>Keep your state in React, possibly derive it from Relay data</li>
<li>Write data back to Relay via mutations or local update</li>
</ol>
<h2><a class="anchor" aria-hidden="true" id="accessing-data-outside-react"></a><a href="#accessing-data-outside-react" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Accessing Data Outside React</h2>
<p>This section covers less common use cases, which involve fetching and accessing data outside of our React APIs. Most of the time you will be directly using our React APIs, so you don't need to know this to start building with Relay. However, these APIs can be useful for more advanced use cases when you need more control over how data is fetched and managed, for example when writing pieces of infrastructure on top of Relay.</p>
<h3><a class="anchor" aria-hidden="true" id="fetching-queries"></a><a href="#fetching-queries" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fetching Queries</h3>
<p>If you want to fetch a query outside of React, you can use the <strong><code>fetchQuery</code></strong> function, which returns an observable:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {AppQuery} <span class="hljs-keyword">from</span> <span class="hljs-string">'AppQuery.graphql'</span>;

<span class="hljs-keyword">const</span> {fetchQuery} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

fetchQuery&lt;AppQuery&gt;(
  environment,
  graphql<span class="hljs-string">`
    query AppQuery($id: ID!) {
      user(id: $id) {
        name
      }
    }
  `</span>,
  {<span class="hljs-attr">id</span>: <span class="hljs-number">4</span>},
)
.subscribe({
  <span class="hljs-attr">start</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {...},
  <span class="hljs-attr">complete</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {...},
  <span class="hljs-attr">error</span>: <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {...},
  <span class="hljs-attr">next</span>: <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {...}
});
</code></pre>
<ul>
<li><code>fetchQuery</code> will automatically save the fetched data to the in-memory Relay store, and notify any components subscribed to the relevant data.</li>
<li><code>fetchQuery</code> will <strong><em>NOT</em></strong> retain the data for the query, meaning that it is not guaranteed that the data will remain saved in the Relay store at any point after the request completes. If you wish to make sure that the data is retained outside of the scope of the request, you need to call <code>environment.retain()</code> directly on the query to ensure it doesn't get deleted. See <a href="#retaining-queries">Retaining Queries</a> for more details.</li>
<li>The data provided in the <code>next</code> callback represents a snapshot of the query data read from the Relay store at the moment a payload was received from the server.</li>
<li>Note that we specify the <code>AppQuery</code> Flow type; this ensures that the type of the data provided by the observable matches the shape of the query, and enforces that the <code>variables</code> passed as input to <code>fetchQuery</code> match the type of the variables expected by the query.</li>
</ul>
<p>If desired, you can convert the request into a Promise using <strong><code>.toPromise()</code></strong>:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> type {AppQuery} <span class="hljs-keyword">from</span> <span class="hljs-string">'AppQuery.graphql'</span>;

<span class="hljs-keyword">const</span> {fetchQuery} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-relay/hooks'</span>);

fetchQuery&lt;AppQuery&gt;(
  environment,
  graphql<span class="hljs-string">`
    query AppQuery($id: ID!) {
      user(id: $id) {
        name
      }
    }
  `</span>,
  {<span class="hljs-attr">id</span>: <span class="hljs-number">4</span>},
)
.toPromise()
.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {...})
.catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {...};
</code></pre>
<ul>
<li>The returned Promise that resolves to the query data, read out from the store when the first network response is received from the server. If the request fails, the promise will reject</li>
<li>Note that we specify the <code>AppQuery</code> Flow type; this ensures that the type of the data the the promise will resolve to matches the shape of the query, and enforces that the <code>variables</code> passed as input to <code>fetchQuery</code> match the type of the variables expected by the query.</li>
</ul>
<blockquote>
<p>See also our API Reference for <a href="api-reference.html#fetchquery">fetchQuery</a>.</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="prefetching-queries"></a><a href="#prefetching-queries" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Prefetching Queries</h3>
<p>This section covers prefetching queries from the client (if you're interested in preloading for initial load or transitions,  see our <a href="#preloading-data">Preloading Data</a> section). Prefetching queries can be useful to anticipate user actions and increase the likelihood of data being immediately available when the user requests it.</p>
<blockquote>
<p><strong>TODO</strong></p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="subscribing-to-queries"></a><a href="#subscribing-to-queries" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Subscribing to Queries</h3>
<blockquote>
<p><strong>TODO</strong></p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="reading-queries-from-local-cache"></a><a href="#reading-queries-from-local-cache" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reading Queries from Local Cache</h3>
<blockquote>
<p><strong>TODO</strong></p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="reading-fragments-from-local-cache"></a><a href="#reading-fragments-from-local-cache" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reading Fragments from Local Cache</h3>
<blockquote>
<p><strong>TODO</strong></p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="retaining-queries"></a><a href="#retaining-queries" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Retaining Queries</h3>
<p>In order to manually retain a query so that the data it references isn't garbage collected by Relay, we can use the <strong><code>environment.retain</code></strong> method:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> {
  createOperationDescriptor,
  getRequest,
  graphql,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'relay-runtime'</span>)

<span class="hljs-comment">// Query graphql object</span>
<span class="hljs-keyword">const</span> query = graphql<span class="hljs-string">`...`</span>;

<span class="hljs-comment">// Construct Relay's internal representation of the query</span>
<span class="hljs-keyword">const</span> queryRequest = getRequest(query)
<span class="hljs-keyword">const</span> queryDescriptor = createOperationDescriptor(
  queryRequest,
  variables
);

<span class="hljs-comment">// Retain query; this will prevent the data for this query and</span>
<span class="hljs-comment">// variables from being garbage collected by Relay</span>
<span class="hljs-keyword">const</span> disposable = environment.retain(queryDescriptor);

<span class="hljs-comment">// Disposing of the disposable will release the data for this query</span>
<span class="hljs-comment">// and variables, meaning that it can be deleted at any moment</span>
<span class="hljs-comment">// by Relay's garbage collection if it hasn't been retained elsewhere</span>
disposable.dispose();
</code></pre>
<ul>
<li><strong>NOTE:</strong> Relay automatically manages the query data retention based on any mounted query components that are rendering the data, so* you usually should <strong><em>not</em></strong> need to call <code>retain</code> directly within product code. For any advanced or special use cases, query data retention should usually be handled within infra-level code, such as a Router.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="testing"></a><a href="#testing" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Testing</h2>
<p>See this guide for <a href="https://relay.dev/docs/en/testing-relay-components">Testing Relay Components</a>, which also applies for any components built using Relay Hooks.</p>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 2020. 2. 2. by Tony</em></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#example-app">Example App</a></li><li><a href="#setup-and-workflow">Setup and Workflow</a><ul class="toc-headings"><li><a href="#installation">Installation</a></li><li><a href="#babel-plugin">Babel plugin</a></li><li><a href="#relay-compiler">Relay Compiler</a></li><li><a href="#config-file">Config file</a></li></ul></li><li><a href="#rendering-data-basics">Rendering Data Basics</a><ul class="toc-headings"><li><a href="#fragments">Fragments</a></li><li><a href="#composing-fragments">Composing Fragments</a></li><li><a href="#queries">Queries</a></li><li><a href="#variables">Variables</a></li><li><a href="#arguments-and-argumentdefinitions"><code>@arguments</code> and <code>@argumentDefinitions</code></a></li><li><a href="#loading-states-with-suspense">Loading States with Suspense</a></li><li><a href="#error-states-with-error-boundaries">Error States with Error Boundaries</a></li><li><a href="#environment">Environment</a></li></ul></li><li><a href="#reusing-cached-data-for-render">Reusing Cached Data for Render</a><ul class="toc-headings"><li><a href="#fetch-policies">Fetch Policies</a></li><li><a href="#availability-of-cached-data">Availability of Cached Data</a></li><li><a href="#presence-of-data">Presence of Data</a></li><li><a href="#staleness-of-data">Staleness of Data</a></li><li><a href="#rendering-partially-cached-data-highly-experimental">Rendering Partially Cached Data [HIGHLY EXPERIMENTAL]</a></li><li><a href="#filling-in-missing-data-missing-data-handlers">Filling in Missing Data (Missing Data Handlers)</a></li></ul></li><li><a href="#fetching-rendering-different-data">Fetching Rendering <em>Different</em> Data</a><ul class="toc-headings"><li><a href="#refreshing-rendered-data">Refreshing Rendered Data</a></li><li><a href="#re-rendering-with-different-data">Re-rendering with Different Data</a></li></ul></li><li><a href="#rendering-list-data-and-pagination">Rendering List Data and Pagination</a><ul class="toc-headings"><li><a href="#connections">Connections</a></li><li><a href="#rendering-connections">Rendering Connections</a></li><li><a href="#pagination">Pagination</a></li><li><a href="#blocking-quot-all-at-once-quot-pagination">Blocking (&quot;all-at-once&quot;) Pagination</a></li><li><a href="#using-and-changing-filters">Using and Changing Filters</a></li><li><a href="#adding-and-removing-items-from-a-connection">Adding and Removing Items From a Connection</a></li><li><a href="#connection-records">Connection Records</a></li><li><a href="#adding-edges">Adding Edges</a></li><li><a href="#removing-edges">Removing Edges</a></li><li><a href="#connection-identity-with-filters">Connection Identity With Filters</a></li><li><a href="#advanced-pagination-use-cases">Advanced Pagination Use Cases</a></li></ul></li><li><a href="#advanced-data-fetching">Advanced Data Fetching</a><ul class="toc-headings"><li><a href="#preloading-data">Preloading Data</a></li><li><a href="#incremental-data-delivery">Incremental Data Delivery</a></li><li><a href="#data-driven-dependencies">Data-driven Dependencies</a></li><li><a href="#image-prefetching">Image Prefetching</a></li></ul></li><li><a href="#updating-data">Updating Data</a><ul class="toc-headings"><li><a href="#graphql-mutations">GraphQL Mutations</a></li><li><a href="#graphql-subscriptions">GraphQL Subscriptions</a></li><li><a href="#local-data-updates">Local Data Updates</a></li><li><a href="#client-only-data-client-schema-extensions">Client-Only Data (Client Schema Extensions)</a></li></ul></li><li><a href="#local-application-state-management">Local Application State Management</a></li><li><a href="#accessing-data-outside-react">Accessing Data Outside React</a><ul class="toc-headings"><li><a href="#fetching-queries">Fetching Queries</a></li><li><a href="#prefetching-queries">Prefetching Queries</a></li><li><a href="#subscribing-to-queries">Subscribing to Queries</a></li><li><a href="#reading-queries-from-local-cache">Reading Queries from Local Cache</a></li><li><a href="#reading-fragments-from-local-cache">Reading Fragments from Local Cache</a></li><li><a href="#retaining-queries">Retaining Queries</a></li></ul></li><li><a href="#testing">Testing</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/relay.svg" alt="Relay" width="66" height="58"/></a><div><h5>Î¨∏ÏÑú</h5><a href="/docs/introduction-to-relay.html">ÏãúÏûëÌïòÍ∏∞</a></div><div><h5>Ïª§ÎÆ§ÎãàÌã∞</h5><a href="/users.html">Ïú†Ï†Ä Showcase</a></div><div><h5>Îçî Î≥¥Í∏∞</h5><a href="https://github.com/facebook/relay">GitHub</a><a class="github-button" href="https://github.com/facebook/relay" data-icon="octicon-star" data-count-href="/facebook/relay/stargazers" data-count-api="/repos/facebook/relay#stargazers_count" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright ¬© 2022 Facebook Inc. / Translated by Tony (@tonyfromundefined)</section></footer></div></body></html>